{"$type":"MixItUp.Base.Model.Commands.TwitchChannelPointsCommandModel, MixItUp.Base","ChannelPointRewardID":"c777e3b8-3a9e-484c-bcbd-b3b222def8c2","ID":"ebbea783-fb72-45c1-8158-4cbb4a2da99f","Name":"SAM","Type":7,"IsEnabled":true,"Unlocked":false,"IsEmbedded":false,"GroupName":"User Rewards","Triggers":[],"Requirements":{"$type":"MixItUp.Base.Model.Requirements.RequirementsSetModel, MixItUp.Base","Requirements":[]},"Actions":[{"$type":"MixItUp.Base.Model.Actions.SpecialIdentifierActionModel, MixItUp.Base","SpecialIdentifierName":"pitch","ReplacementText":"72","MakeGloballyUsable":false,"ShouldProcessMath":false,"ReplaceSpecialIdentifiersInFunctions":false,"ID":"361c8fe3-10c2-488d-baaf-a13ad5da037f","Name":"Pitch","Type":12,"Enabled":true},{"$type":"MixItUp.Base.Model.Actions.SpecialIdentifierActionModel, MixItUp.Base","SpecialIdentifierName":"speed","ReplacementText":"64","MakeGloballyUsable":false,"ShouldProcessMath":false,"ReplaceSpecialIdentifiersInFunctions":false,"ID":"ed3ac74e-d1fa-4339-bace-f893f4aeb8dc","Name":"Speed","Type":12,"Enabled":true},{"$type":"MixItUp.Base.Model.Actions.SpecialIdentifierActionModel, MixItUp.Base","SpecialIdentifierName":"mouth","ReplacementText":"128","MakeGloballyUsable":false,"ShouldProcessMath":false,"ReplaceSpecialIdentifiersInFunctions":false,"ID":"85a40e6f-a38d-4a2f-aadf-469930de5eee","Name":"Mouth","Type":12,"Enabled":true},{"$type":"MixItUp.Base.Model.Actions.SpecialIdentifierActionModel, MixItUp.Base","SpecialIdentifierName":"throat","ReplacementText":"128","MakeGloballyUsable":false,"ShouldProcessMath":false,"ReplaceSpecialIdentifiersInFunctions":false,"ID":"adab17dd-aa5c-4353-85e5-8cb969c560de","Name":"Throat","Type":12,"Enabled":true},{"$type":"MixItUp.Base.Model.Actions.SpecialIdentifierActionModel, MixItUp.Base","SpecialIdentifierName":"samargs","ReplacementText":"$message","MakeGloballyUsable":false,"ShouldProcessMath":false,"ReplaceSpecialIdentifiersInFunctions":false,"ID":"8e42c7c1-603e-464b-a704-e7314c61d412","Name":"CHANGE IF NEEDED","Type":12,"Enabled":true},{"$type":"MixItUp.Base.Model.Actions.OverlayActionModel, MixItUp.Base","OverlayName":null,"OverlayItem":null,"OverlayItemV3":{"$type":"MixItUp.Base.Model.Overlay.OverlayHTMLV3Model, MixItUp.Base","Version":0,"OverlayEndpointID":"00000000-0000-0000-0000-000000000000","Type":4,"DisplayOption":0,"Width":0,"Height":0,"PositionType":0,"XPosition":50,"YPosition":50,"XMaximum":0,"YMaximum":0,"Layer":0,"OldCustomHTML":null,"ID":"00000000-0000-0000-0000-000000000000","HTML":"<div id=\"maindiv\" class=\"maindiv\">\r\n<div id=\"contentdiv\" class=\"contentdiv\">\r\n\r\n\n\r\n\r\n</div>\r\n</div>","CSS":".maindiv {\r\n    position: absolute;\r\n    width: 100%;\r\n    max-width: 100%;\r\n    min-width: 100%;\r\n    height: 100%;\r\n    max-height: 100%;\r\n    min-height: 100%;\r\n    margin: 0px;\r\n    z-index: {Layer};\r\n}\r\n\r\n.contentdiv {\r\n    position: absolute;\r\n    margin: 0px;\r\n    left: {XPosition}{PositionTypeUnit};\r\n    top: {YPosition}{PositionTypeUnit};\r\n    transform: translate({XTranslation}%, {YTranslation}%);\r\n    width: {Width};\r\n    height: {Height};\r\n}\r\n\r\n\n","Javascript":"const main = document.getElementById(\"maindiv\");\r\n\r\nconst duration = {Duration} * 1000;\r\n\r\nfunction removeSelf()\r\n{\r\n    main.style.visibility='hidden';\r\n    sendParentMessage({ Type: \"Remove\", ID: \"{ID}\" });\r\n}\r\n\r\nperformAnimation(\"{EntranceAnimationFramework}\", \"{EntranceAnimationName}\", main).then((result) =>\r\n{\r\n    {CustomAnimations}\r\n\r\n    if (duration > 0.0)\r\n    {\r\n        setTimeout(() =>\r\n        {\r\n            performAnimation(\"{ExitAnimationFramework}\", \"{ExitAnimationName}\", main).then((result) =>\r\n            {\r\n                removeSelf();\r\n            });\r\n        }, duration);\r\n    }\r\n});\r\n\r\n/**\r\n * This is SamJs.js v0.3.0\r\n *\r\n * A Javascript port of \"SAM Software Automatic Mouth\".\r\n *\r\n * (c) 2017-2024 Christian Schiffler\r\n *\r\n * @link(https://github.com/discordier/sam)\r\n *\r\n * @author 2017 Christian Schiffler <c.schiffler@cyberspectrum.de>\r\n */\r\n(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SamJs = factory());\r\n})(this, (function () { 'use strict';\r\n\r\n  /**\r\n   * Test if a bit is set.\r\n   * @param {Number} bits The bits.\r\n   * @param {Number} mask The mask to test.\r\n   * @return {boolean}\r\n   */\r\n  let matchesBitmask = (bits, mask) => {\r\n    return (bits & mask) !== 0;\r\n  };\r\n  let text2Uint8Array = text => {\r\n    let buffer = new Uint8Array(text.length);\r\n    text.split('').forEach((e, index) => {\r\n      buffer[index] = e.charCodeAt(0);\r\n    });\r\n    return buffer;\r\n  };\r\n  let Uint32ToUint8Array = uint32 => {\r\n    let result = new Uint8Array(4);\r\n    result[0] = uint32;\r\n    result[1] = uint32 >> 8;\r\n    result[2] = uint32 >> 16;\r\n    result[3] = uint32 >> 24;\r\n    return result;\r\n  };\r\n  let Uint16ToUint8Array = uint16 => {\r\n    let result = new Uint8Array(2);\r\n    result[0] = uint16;\r\n    result[1] = uint16 >> 8;\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param {AudioContext} context\r\n   * @param {Float32Array} audiobuffer\r\n   *\r\n   * @return {Promise}\r\n   */\r\n  let Play = (context, audiobuffer) => {\r\n    let abort;\r\n    let promise = new Promise((resolve, reject) => {\r\n      let source = context.createBufferSource();\r\n      let soundBuffer = context.createBuffer(1, audiobuffer.length, 22050);\r\n      let buffer = soundBuffer.getChannelData(0);\r\n      for (let i = 0; i < audiobuffer.length; i++) {\r\n        buffer[i] = audiobuffer[i];\r\n      }\r\n      source.buffer = soundBuffer;\r\n      source.connect(context.destination);\r\n      source.onended = () => {\r\n        resolve(true);\r\n      };\r\n      abort = reason => {\r\n        source.disconnect();\r\n        reject(reason);\r\n      };\r\n      source.start(0);\r\n    });\r\n    promise.abort = abort;\r\n    return promise;\r\n  };\r\n  let context = null;\r\n\r\n  /**\r\n   * Play an audio buffer.\r\n   *\r\n   * @param {Float32Array} audiobuffer\r\n   *\r\n   * @return {Promise}\r\n   */\r\n  let PlayBuffer = audiobuffer => {\r\n    if (null === context) {\r\n      context = new AudioContext();\r\n    }\r\n    if (!context) {\r\n      {\r\n        throw new Error('No player available!');\r\n      }\r\n    }\r\n    return Play(context, audiobuffer);\r\n  };\r\n\r\n  /**\r\n   * Convert a Uint8Array wave buffer to a Float32Array WaveBuffer\r\n   *\r\n   * @param {Uint8Array} buffer\r\n   *\r\n   * @return {Float32Array}\r\n   */\r\n  let Uint8ArrayToFloat32Array = buffer => {\r\n    let audio = new Float32Array(buffer.length);\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      audio[i] = (buffer[i] - 128) / 256;\r\n    }\r\n    return audio;\r\n  };\r\n\r\n  /**\r\n   * Converts a Uint8Array buffer to a Uint8Array wave buffer\r\n   *\r\n   * @param {Uint8Array} audiobuffer\r\n   *\r\n   * @return {Uint8Array}\r\n   */\r\n  let ToWavBuffer = audiobuffer => {\r\n    // Calculate buffer size.\r\n    let realbuffer = new Uint8Array(4 +\r\n    // \"RIFF\"\r\n    4 +\r\n    // uint32 filesize\r\n    4 +\r\n    // \"WAVE\"\r\n    4 +\r\n    // \"fmt \"\r\n    4 +\r\n    // uint32 fmt length\r\n    2 +\r\n    // uint16 fmt\r\n    2 +\r\n    // uint16 channels\r\n    4 +\r\n    // uint32 sample rate\r\n    4 +\r\n    // uint32 bytes per second\r\n    2 +\r\n    // uint16 block align\r\n    2 +\r\n    // uint16 bits per sample\r\n    4 +\r\n    // \"data\"\r\n    4 +\r\n    // uint32 chunk length\r\n    audiobuffer.length);\r\n    let pos = 0;\r\n    let write = buffer => {\r\n      realbuffer.set(buffer, pos);\r\n      pos += buffer.length;\r\n    };\r\n\r\n    //RIFF header\r\n    write(text2Uint8Array('RIFF')); // chunkID\r\n    write(Uint32ToUint8Array(audiobuffer.length + 12 + 16 + 8 - 8)); // ChunkSize\r\n    write(text2Uint8Array('WAVE')); // riffType\r\n    //format chunk\r\n    write(text2Uint8Array('fmt '));\r\n    write(Uint32ToUint8Array(16)); // ChunkSize\r\n    write(Uint16ToUint8Array(1)); // wFormatTag - 1 = PCM\r\n    write(Uint16ToUint8Array(1)); // channels\r\n    write(Uint32ToUint8Array(22050)); // samplerate\r\n    write(Uint32ToUint8Array(22050)); // bytes/second\r\n    write(Uint16ToUint8Array(1)); // blockalign\r\n    write(Uint16ToUint8Array(8)); // bits per sample\r\n    //data chunk\r\n    write(text2Uint8Array('data'));\r\n    write(Uint32ToUint8Array(audiobuffer.length)); // buffer length\r\n    write(audiobuffer);\r\n    return realbuffer;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param {Uint8Array} audiobuffer\r\n   *\r\n   * @return void\r\n   */\r\n  let RenderBuffer = audiobuffer => {\r\n    let filename = \"sam.wav\";\r\n    let blob = new Blob([ToWavBuffer(audiobuffer)], {\r\n      type: \"audio/vnd.wave\"\r\n    });\r\n    let url = window.URL || window.webkitURL;\r\n    let fileURL = url.createObjectURL(blob);\r\n    let a = document.createElement('a');\r\n    a.href = fileURL;\r\n    a.target = '_blank';\r\n    a.download = filename;\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    document.body.removeChild(a);\r\n    url.revokeObjectURL(fileURL);\r\n  };\r\n\r\n  /**\r\n   * Char flags.\r\n   *\r\n   *  0x01        numeric\r\n   *  0x02        use rule set 2\r\n   *  0x04        D J L N R S T Z\r\n   *  0x08        B D G J L M N R V W Z\r\n   *  0x10        C G J S X Z\r\n   *  0x20        B C D F G H J K L M N P Q R S T V W X Y Z + ` => probably all consonants and '`'?\r\n   *  0x40        is vowel or Y\r\n   *  0x80        alpha or '\r\n   */\r\n  let charFlags = {\r\n    ' ': 0,\r\n    '!': 0 | 0x02,\r\n    '\"': 0 | 0x02,\r\n    '#': 0 | 0x02,\r\n    '$': 0 | 0x02,\r\n    '%': 0 | 0x02,\r\n    '&': 0 | 0x02,\r\n    '\\'': 0 | 0x80 | 0x02,\r\n    '(': 0,\r\n    ')': 0,\r\n    '*': 0 | 0x02,\r\n    '+': 0 | 0x02,\r\n    ',': 0 | 0x02,\r\n    '-': 0 | 0x02,\r\n    '.': 0 | 0x02,\r\n    '/': 0 | 0x02,\r\n    '0': 0 | 0x02 | 0x01,\r\n    '1': 0 | 0x02 | 0x01,\r\n    '2': 0 | 0x02 | 0x01,\r\n    '3': 0 | 0x02 | 0x01,\r\n    '4': 0 | 0x02 | 0x01,\r\n    '5': 0 | 0x02 | 0x01,\r\n    '6': 0 | 0x02 | 0x01,\r\n    '7': 0 | 0x02 | 0x01,\r\n    '8': 0 | 0x02 | 0x01,\r\n    '9': 0 | 0x02 | 0x01,\r\n    ':': 0 | 0x02,\r\n    ';': 0 | 0x02,\r\n    '<': 0 | 0x02,\r\n    '=': 0 | 0x02,\r\n    '>': 0 | 0x02,\r\n    '?': 0 | 0x02,\r\n    '@': 0 | 0x02,\r\n    'A': 0 | 0x80 | 0x40,\r\n    'B': 0 | 0x80 | 0x20 | 0x08,\r\n    'C': 0 | 0x80 | 0x20 | 0x10,\r\n    'D': 0 | 0x80 | 0x20 | 0x08 | 0x04,\r\n    'E': 0 | 0x80 | 0x40,\r\n    'F': 0 | 0x80 | 0x20,\r\n    'G': 0 | 0x80 | 0x20 | 0x10 | 0x08,\r\n    'H': 0 | 0x80 | 0x20,\r\n    'I': 0 | 0x80 | 0x40,\r\n    'J': 0 | 0x80 | 0x20 | 0x10 | 0x08 | 0x04,\r\n    'K': 0 | 0x80 | 0x20,\r\n    'L': 0 | 0x80 | 0x20 | 0x08 | 0x04,\r\n    'M': 0 | 0x80 | 0x20 | 0x08,\r\n    'N': 0 | 0x80 | 0x20 | 0x08 | 0x04,\r\n    'O': 0 | 0x80 | 0x40,\r\n    'P': 0 | 0x80 | 0x20,\r\n    'Q': 0 | 0x80 | 0x20,\r\n    'R': 0 | 0x80 | 0x20 | 0x08 | 0x04,\r\n    'S': 0 | 0x80 | 0x20 | 0x10 | 0x04,\r\n    'T': 0 | 0x80 | 0x20 | 0x04,\r\n    'U': 0 | 0x80 | 0x40,\r\n    'V': 0 | 0x80 | 0x20 | 0x08,\r\n    'W': 0 | 0x80 | 0x20 | 0x08,\r\n    'X': 0 | 0x80 | 0x20 | 0x10,\r\n    'Y': 0 | 0x80 | 0x40,\r\n    'Z': 0 | 0x80 | 0x20 | 0x10 | 0x08 | 0x04,\r\n    '[': 0,\r\n    '\\\\': 0,\r\n    ']': 0,\r\n    '^': 0 | 0x02,\r\n    '_': 0,\r\n    '`': 0 | 0x20\r\n  };\r\n  let rules$1 = ' (A.)=EH4Y. |' + '(A) =AH|' + ' (ARE) =AAR|' + ' (AR)O=AXR|' + '(AR)#=EH4R|' + ' ^(AS)#=EY4S|' + '(A)WA=AX|' + '(AW)=AO5|' + ' :(ANY)=EH4NIY|' + '(A)^+#=EY5|' + '#:(ALLY)=ULIY|' + ' (AL)#=UL|' + '(AGAIN)=AXGEH4N|' + '#:(AG)E=IHJ|' + '(A)^%=EY|' + '(A)^+:#=AE|' + ' :(A)^+ =EY4|' + ' (ARR)=AXR|' + '(ARR)=AE4R|' + ' ^(AR) =AA5R|' + '(AR)=AA5R|' + '(AIR)=EH4R|' + '(AI)=EY4|' + '(AY)=EY5|' + '(AU)=AO4|' + '#:(AL) =UL|' + '#:(ALS) =ULZ|' + '(ALK)=AO4K|' + '(AL)^=AOL|' + ' :(ABLE)=EY4BUL|' + '(ABLE)=AXBUL|' + '(A)VO=EY4|' + '(ANG)+=EY4NJ|' + '(ATARI)=AHTAA4RIY|' + '(A)TOM=AE|' + '(A)TTI=AE|' + ' (AT) =AET|' + ' (A)T=AH|' + '(A)=AE|' + ' (B) =BIY4|' + ' (BE)^#=BIH|' + '(BEING)=BIY4IHNX|' + ' (BOTH) =BOW4TH|' + ' (BUS)#=BIH4Z|' + '(BREAK)=BREY5K|' + '(BUIL)=BIH4L|' + '(B)=B|' + ' (C) =SIY4|' + ' (CH)^=K|' + '^E(CH)=K|' + '(CHA)R#=KEH5|' + '(CH)=CH|' + ' S(CI)#=SAY4|' + '(CI)A=SH|' + '(CI)O=SH|' + '(CI)EN=SH|' + '(CITY)=SIHTIY|' + '(C)+=S|' + '(CK)=K|' + '(COMMODORE)=KAA4MAHDOHR|' + '(COM)=KAHM|' + '(CUIT)=KIHT|' + '(CREA)=KRIYEY|' + '(C)=K|' + ' (D) =DIY4|' + ' (DR.) =DAA4KTER|' + '#:(DED) =DIHD|' + '.E(D) =D|' + '#:^E(D) =T|' + ' (DE)^#=DIH|' + ' (DO) =DUW|' + ' (DOES)=DAHZ|' + '(DONE) =DAH5N|' + '(DOING)=DUW4IHNX|' + ' (DOW)=DAW|' + '#(DU)A=JUW|' + '#(DU)^#=JAX|' + '(D)=D|' + ' (E) =IYIY4|' + '#:(E) =|' + '\\':^(E) =|' + ' :(E) =IY|' + '#(ED) =D|' + '#:(E)D =|' + '(EV)ER=EH4V|' + '(E)^%=IY4|' + '(ERI)#=IY4RIY|' + '(ERI)=EH4RIH|' + '#:(ER)#=ER|' + '(ERROR)=EH4ROHR|' + '(ERASE)=IHREY5S|' + '(ER)#=EHR|' + '(ER)=ER|' + ' (EVEN)=IYVEHN|' + '#:(E)W=|' + '@(EW)=UW|' + '(EW)=YUW|' + '(E)O=IY|' + '#:&(ES) =IHZ|' + '#:(E)S =|' + '#:(ELY) =LIY|' + '#:(EMENT)=MEHNT|' + '(EFUL)=FUHL|' + '(EE)=IY4|' + '(EARN)=ER5N|' + ' (EAR)^=ER5|' + '(EAD)=EHD|' + '#:(EA) =IYAX|' + '(EA)SU=EH5|' + '(EA)=IY5|' + '(EIGH)=EY4|' + '(EI)=IY4|' + ' (EYE)=AY4|' + '(EY)=IY|' + '(EU)=YUW5|' + '(EQUAL)=IY4KWUL|' + '(E)=EH|' + ' (F) =EH4F|' + '(FUL)=FUHL|' + '(FRIEND)=FREH5ND|' + '(FATHER)=FAA4DHER|' + '(F)F=|' + '(F)=F|' + ' (G) =JIY4|' + '(GIV)=GIH5V|' + ' (G)I^=G|' + '(GE)T=GEH5|' + 'SU(GGES)=GJEH4S|' + '(GG)=G|' + ' B#(G)=G|' + '(G)+=J|' + '(GREAT)=GREY4T|' + '(GON)E=GAO5N|' + '#(GH)=|' + ' (GN)=N|' + '(G)=G|' + ' (H) =EY4CH|' + ' (HAV)=/HAE6V|' + ' (HERE)=/HIYR|' + ' (HOUR)=AW5ER|' + '(HOW)=/HAW|' + '(H)#=/H|' + '(H)=|' + ' (IN)=IHN|' + ' (I) =AY4|' + '(I) =AY|' + '(IN)D=AY5N|' + 'SEM(I)=IY|' + ' ANT(I)=AY|' + '(IER)=IYER|' + '#:R(IED) =IYD|' + '(IED) =AY5D|' + '(IEN)=IYEHN|' + '(IE)T=AY4EH|' + '(I\\')=AY5|' + ' :(I)^%=AY5|' + ' :(IE) =AY4|' + '(I)%=IY|' + '(IE)=IY4|' + ' (IDEA)=AYDIY5AH|' + '(I)^+:#=IH|' + '(IR)#=AYR|' + '(IZ)%=AYZ|' + '(IS)%=AYZ|' + 'I^(I)^#=IH|' + '+^(I)^+=AY|' + '#:^(I)^+=IH|' + '(I)^+=AY|' + '(IR)=ER|' + '(IGH)=AY4|' + '(ILD)=AY5LD|' + ' (IGN)=IHGN|' + '(IGN) =AY4N|' + '(IGN)^=AY4N|' + '(IGN)%=AY4N|' + '(ICRO)=AY4KROH|' + '(IQUE)=IY4K|' + '(I)=IH|' + ' (J) =JEY4|' + '(J)=J|' + ' (K) =KEY4|' + ' (K)N=|' + '(K)=K|' + ' (L) =EH4L|' + '(LO)C#=LOW|' + 'L(L)=|' + '#:^(L)%=UL|' + '(LEAD)=LIYD|' + ' (LAUGH)=LAE4F|' + '(L)=L|' + ' (M) =EH4M|' + ' (MR.) =MIH4STER|' + ' (MS.)=MIH5Z|' + ' (MRS.) =MIH4SIXZ|' + '(MOV)=MUW4V|' + '(MACHIN)=MAHSHIY5N|' + 'M(M)=|' + '(M)=M|' + ' (N) =EH4N|' + 'E(NG)+=NJ|' + '(NG)R=NXG|' + '(NG)#=NXG|' + '(NGL)%=NXGUL|' + '(NG)=NX|' + '(NK)=NXK|' + ' (NOW) =NAW4|' + 'N(N)=|' + '(NON)E=NAH4N|' + '(N)=N|' + ' (O) =OH4W|' + '(OF) =AHV|' + ' (OH) =OW5|' + '(OROUGH)=ER4OW|' + '#:(OR) =ER|' + '#:(ORS) =ERZ|' + '(OR)=AOR|' + ' (ONE)=WAHN|' + '#(ONE) =WAHN|' + '(OW)=OW|' + ' (OVER)=OW5VER|' + 'PR(O)V=UW4|' + '(OV)=AH4V|' + '(O)^%=OW5|' + '(O)^EN=OW|' + '(O)^I#=OW5|' + '(OL)D=OW4L|' + '(OUGHT)=AO5T|' + '(OUGH)=AH5F|' + ' (OU)=AW|' + 'H(OU)S#=AW4|' + '(OUS)=AXS|' + '(OUR)=OHR|' + '(OULD)=UH5D|' + '(OU)^L=AH5|' + '(OUP)=UW5P|' + '(OU)=AW|' + '(OY)=OY|' + '(OING)=OW4IHNX|' + '(OI)=OY5|' + '(OOR)=OH5R|' + '(OOK)=UH5K|' + 'F(OOD)=UW5D|' + 'L(OOD)=AH5D|' + 'M(OOD)=UW5D|' + '(OOD)=UH5D|' + 'F(OOT)=UH5T|' + '(OO)=UW5|' + '(O\\')=OH|' + '(O)E=OW|' + '(O) =OW|' + '(OA)=OW4|' + ' (ONLY)=OW4NLIY|' + ' (ONCE)=WAH4NS|' + '(ON\\'T)=OW4NT|' + 'C(O)N=AA|' + '(O)NG=AO|' + ' :^(O)N=AH|' + 'I(ON)=UN|' + '#:(ON)=UN|' + '#^(ON)=UN|' + '(O)ST=OW|' + '(OF)^=AO4F|' + '(OTHER)=AH5DHER|' + 'R(O)B=RAA|' + '^R(O):#=OW5|' + '(OSS) =AO5S|' + '#:^(OM)=AHM|' + '(O)=AA|' + ' (P) =PIY4|' + '(PH)=F|' + '(PEOPL)=PIY5PUL|' + '(POW)=PAW4|' + '(PUT) =PUHT|' + '(P)P=|' + '(P)S=|' + '(P)N=|' + '(PROF.)=PROHFEH4SER|' + '(P)=P|' + ' (Q) =KYUW4|' + '(QUAR)=KWOH5R|' + '(QU)=KW|' + '(Q)=K|' + ' (R) =AA5R|' + ' (RE)^#=RIY|' + '(R)R=|' + '(R)=R|' + ' (S) =EH4S|' + '(SH)=SH|' + '#(SION)=ZHUN|' + '(SOME)=SAHM|' + '#(SUR)#=ZHER|' + '(SUR)#=SHER|' + '#(SU)#=ZHUW|' + '#(SSU)#=SHUW|' + '#(SED)=ZD|' + '#(S)#=Z|' + '(SAID)=SEHD|' + '^(SION)=SHUN|' + '(S)S=|' + '.(S) =Z|' + '#:.E(S) =Z|' + '#:^#(S) =S|' + 'U(S) =S|' + ' :#(S) =Z|' + '##(S) =Z|' + ' (SCH)=SK|' + '(S)C+=|' + '#(SM)=ZUM|' + '#(SN)\\'=ZUM|' + '(STLE)=SUL|' + '(S)=S|' + ' (T) =TIY4|' + ' (THE) #=DHIY|' + ' (THE) =DHAX|' + '(TO) =TUX|' + ' (THAT)=DHAET|' + ' (THIS) =DHIHS|' + ' (THEY)=DHEY|' + ' (THERE)=DHEHR|' + '(THER)=DHER|' + '(THEIR)=DHEHR|' + ' (THAN) =DHAEN|' + ' (THEM) =DHAEN|' + '(THESE) =DHIYZ|' + ' (THEN)=DHEHN|' + '(THROUGH)=THRUW4|' + '(THOSE)=DHOHZ|' + '(THOUGH) =DHOW|' + '(TODAY)=TUXDEY|' + '(TOMO)RROW=TUMAA5|' + '(TO)TAL=TOW5|' + ' (THUS)=DHAH4S|' + '(TH)=TH|' + '#:(TED)=TIXD|' + 'S(TI)#N=CH|' + '(TI)O=SH|' + '(TI)A=SH|' + '(TIEN)=SHUN|' + '(TUR)#=CHER|' + '(TU)A=CHUW|' + ' (TWO)=TUW|' + '&(T)EN =|' + '(T)=T|' + ' (U) =YUW4|' + ' (UN)I=YUWN|' + ' (UN)=AHN|' + ' (UPON)=AXPAON|' + '@(UR)#=UH4R|' + '(UR)#=YUH4R|' + '(UR)=ER|' + '(U)^ =AH|' + '(U)^^=AH5|' + '(UY)=AY5|' + ' G(U)#=|' + 'G(U)%=|' + 'G(U)#=W|' + '#N(U)=YUW|' + '@(U)=UW|' + '(U)=YUW|' + ' (V) =VIY4|' + '(VIEW)=VYUW5|' + '(V)=V|' + ' (W) =DAH4BULYUW|' + ' (WERE)=WER|' + '(WA)SH=WAA|' + '(WA)ST=WEY|' + '(WA)S=WAH|' + '(WA)T=WAA|' + '(WHERE)=WHEHR|' + '(WHAT)=WHAHT|' + '(WHOL)=/HOWL|' + '(WHO)=/HUW|' + '(WH)=WH|' + '(WAR)#=WEHR|' + '(WAR)=WAOR|' + '(WOR)^=WER|' + '(WR)=R|' + '(WOM)A=WUHM|' + '(WOM)E=WIHM|' + '(WEA)R=WEH|' + '(WANT)=WAA5NT|' + 'ANS(WER)=ER|' + '(W)=W|' + ' (X) =EH4KR|' + ' (X)=Z|' + '(X)=KS|' + ' (Y) =WAY4|' + '(YOUNG)=YAHNX|' + ' (YOUR)=YOHR|' + ' (YOU)=YUW|' + ' (YES)=YEHS|' + ' (Y)=Y|' + 'F(Y)=AY|' + 'PS(YCH)=AYK|' + '#:^(Y)=IY|' + '#:^(Y)I=IY|' + ' :(Y) =AY|' + ' :(Y)#=AY|' + ' :(Y)^+:#=IH|' + ' :(Y)^#=AY|' + '(Y)=IH|' + ' (Z) =ZIY4|' + '(Z)=Z';\r\n  let rules2$1 = '(A)=|' + '(!)=.|' + '(\") =-AH5NKWOWT-|' + '(\")=KWOW4T-|' + '(#)= NAH4MBER|' + '($)= DAA4LER|' + '(%)= PERSEH4NT|' + '(&)= AEND|' + '(\\')=|' + '(*)= AE4STERIHSK|' + '(+)= PLAH4S|' + '(,)=,|' + ' (-) =-|' + '(-)=|' + '(.)= POYNT|' + '(/)= SLAE4SH|' + '(0)= ZIY4ROW|' + ' (1ST)=FER4ST|' + ' (10TH)=TEH4NTH|' + '(1)= WAH4N|' + ' (2ND)=SEH4KUND|' + '(2)= TUW4|' + ' (3RD)=THER4D|' + '(3)= THRIY4|' + '(4)= FOH4R|' + ' (5TH)=FIH4FTH|' + '(5)= FAY4V|' + ' (64) =SIH4KSTIY FOHR|' + '(6)= SIH4KS|' + '(7)= SEH4VUN|' + ' (8TH)=EY4TH|' + '(8)= EY4T|' + '(9)= NAY4N|' + '(:)=.|' + '(;)=.|' + '(<)= LEH4S DHAEN|' + '(=)= IY4KWULZ|' + '(>)= GREY4TER DHAEN|' + '(?)=?|' + '(@)= AE6T|' + '(^)= KAE4RIXT';\r\n\r\n  let FLAG_NUMERIC = 0x01;\r\n  let FLAG_RULESET2 = 0x02;\r\n  let FLAG_VOICED$1 = 0x04; // FIXME: is this correct?\r\n  let FLAG_0X08 = 0x08; // unknown.\r\n  let FLAG_DIPHTHONG$1 = 0x10; // FIXME: is this correct?\r\n  let FLAG_CONSONANT$1 = 0x20; // FIXME: is this correct?\r\n  let FLAG_VOWEL_OR_Y = 0x40;\r\n  let FLAG_ALPHA_OR_QUOT = 0x80;\r\n\r\n  /**\r\n   * Test if the char matches against the flags in the reciter table.\r\n   * @param {string} c\r\n   * @param {Number} flg\r\n   * @return {boolean}\r\n   */\r\n  let flags = (c, flg) => {\r\n    return (charFlags[c] & flg) !== 0;\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param {string} text\r\n   * @param {Number} pos\r\n   * @param {Number} flg\r\n   * @return {boolean}\r\n   */\r\n  let flagsAt = (text, pos, flg) => {\r\n    return flags(text[pos], flg);\r\n  };\r\n  /**\r\n   *\r\n   * @param {string} c\r\n   * @param {Array} list\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  let isOneOf = (c, list) => {\r\n    return list.indexOf(c) !== -1;\r\n  };\r\n\r\n  /**\r\n   * Set a phoneme in the buffer.\r\n   *\r\n   * @callback successCallback\r\n   *\r\n   * @param {string} append    The string to append.\r\n   * @param {Number} inputSkip The amount or chars to move ahead in the input.\r\n   */\r\n\r\n  /**\r\n   * Generator for self processing rule instances.\r\n   * @param {String} ruleString 'xxx(yyy)zzz=foobar' 'xxx(yyy)zzz' is the source value, 'foobar' is the destination value.\r\n   * @return {result}\r\n   */\r\n  let reciterRule = ruleString => {\r\n    let splitted = ruleString.split('=');\r\n    const\r\n      // Must pop and join here because of rule for '=' itself.\r\n      target = splitted.pop(),\r\n      source = splitted.join('=').split('('),\r\n      tmp = source.pop().split(')'),\r\n      pre = source[0],\r\n      match = tmp[0],\r\n      post = tmp[1];\r\n    let TCS = ['T', 'C', 'S'];\r\n    let EIY = ['E', 'I', 'Y'];\r\n\r\n    /**\r\n     * Test if the rule prefix matches.\r\n     * @param {string} text The input text.\r\n     * @param {Number} pos  The input position we are working from.\r\n     * @return {boolean}\r\n     */\r\n    let checkPrefix = (text, pos) => {\r\n      for (let rulePos = pre.length - 1; rulePos > -1; rulePos--) {\r\n        let ruleByte = pre[rulePos];\r\n        if (!flags(ruleByte, FLAG_ALPHA_OR_QUOT)) {\r\n          if (!{\r\n            // '' - previous char must not be alpha or quotation mark.\r\n            ' ': () => !flagsAt(text, --pos, FLAG_ALPHA_OR_QUOT),\r\n            // '#' - previous char must be a vowel or Y.\r\n            '#': () => flagsAt(text, --pos, FLAG_VOWEL_OR_Y),\r\n            // '.' - unknown?\r\n            '.': () => flagsAt(text, --pos, FLAG_0X08),\r\n            // '&' - previous char must be a diphthong or previous chars must be 'CH' or 'SH'\r\n            '&': () => flagsAt(text, --pos, FLAG_DIPHTHONG$1) || isOneOf(text.substr(--pos, 2), ['CH', 'SH']),\r\n            // '@' - previous char must be voiced and not 'H'.\r\n            '@': () => {\r\n              if (flagsAt(text, --pos, FLAG_VOICED$1)) {\r\n                return true;\r\n              }\r\n              let inputChar = text[pos];\r\n              // 'H'\r\n              if (inputChar !== 'H') return false;\r\n              // FIXME: this is always true?!? is there a \"--pos\" missing in original code?\r\n              // Check for 'T', 'C', 'S'\r\n              if (!isOneOf(inputChar, TCS)) {\r\n                return false;\r\n              }\r\n              {\r\n                throw new Error('Is always false but happened? ' + inputChar);\r\n              }\r\n            },\r\n            // '^' - previous char must be a consonant.\r\n            '^': () => flagsAt(text, --pos, FLAG_CONSONANT$1),\r\n            // '+' - previous char must be either 'E', 'I' or 'Y'.\r\n            '+': () => isOneOf(text[--pos], EIY),\r\n            // ':' - walk left in input position until we hit a non consonant or begin of string.\r\n            ':': () => {\r\n              while (pos >= 0) {\r\n                if (!flagsAt(text, pos - 1, FLAG_CONSONANT$1)) break;\r\n                pos--;\r\n              }\r\n              return true;\r\n            }\r\n          }[ruleByte]()) {\r\n            return false;\r\n          }\r\n        }\r\n        // Rule char does not match.\r\n        else if (text[--pos] !== ruleByte) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Test if the rule suffix matches.\r\n     * @param {string} text The input text.\r\n     * @param {Number} pos  The input position we are working from.\r\n     * @return {boolean}\r\n     */\r\n    let checkSuffix = (text, pos) => {\r\n      for (let rulePos = 0; rulePos < post.length; rulePos++) {\r\n        let ruleByte = post[rulePos];\r\n        // do we have to handle the byte specially?\r\n        if (!flags(ruleByte, FLAG_ALPHA_OR_QUOT)) {\r\n          // pos37226:\r\n          if (!{\r\n            // ' ' - next char must not be alpha or quotation mark.\r\n            ' ': () => !flagsAt(text, ++pos, FLAG_ALPHA_OR_QUOT),\r\n            // '#' - next char must be a vowel or Y.\r\n            '#': () => flagsAt(text, ++pos, FLAG_VOWEL_OR_Y),\r\n            // '.' - unknown?\r\n            '.': () => flagsAt(text, ++pos, FLAG_0X08),\r\n            // '&' - next char must be a diphthong or next chars must be 'HC' or 'HS'\r\n            '&': () => flagsAt(text, ++pos, FLAG_DIPHTHONG$1) || isOneOf(text.substr(++pos - 2, 2), ['HC', 'HS']),\r\n            // '@' - next char must be voiced and not 'H'.\r\n            '@': () => {\r\n              if (flagsAt(text, ++pos, FLAG_VOICED$1)) {\r\n                return true;\r\n              }\r\n              let inputChar = text[pos];\r\n              if (inputChar !== 'H')\r\n                // 'H'\r\n                return false;\r\n              // Check for 'T', 'C', 'S'\r\n              if (!isOneOf(inputChar, TCS)) return false;\r\n              // FIXME: This is illogical and can never be reached. Bug in orig. code? reciter.c:489 (pos37367)\r\n              {\r\n                throw new Error('This should not be possible ', inputChar);\r\n              }\r\n            },\r\n            // '^' - next char must be a consonant.\r\n            '^': () => flagsAt(text, ++pos, FLAG_CONSONANT$1),\r\n            // '+' - next char must be either 'E', 'I' or 'Y'.\r\n            '+': () => isOneOf(text[++pos], EIY),\r\n            // ':' - walk right in input position until we hit a non consonant.\r\n            ':': () => {\r\n              while (flagsAt(text, pos + 1, FLAG_CONSONANT$1)) {\r\n                pos++;\r\n              }\r\n              return true;\r\n            },\r\n            /* '%' - check if we have:\r\n              - 'ING'\r\n              - 'E' not followed by alpha or quot\r\n              - 'ER' 'ES' or 'ED'\r\n              - 'EFUL'\r\n              - 'ELY'\r\n            */\r\n            '%': () => {\r\n              // If not 'E', check if 'ING'.\r\n              if (text[pos + 1] !== 'E') {\r\n                // Are next chars \"ING\"?\r\n                if (text.substr(pos + 1, 3) === 'ING') {\r\n                  pos += 3;\r\n                  return true;\r\n                }\r\n                return false;\r\n              }\r\n              // we have 'E' - check if not followed by alpha or quot.\r\n              if (!flagsAt(text, pos + 2, FLAG_ALPHA_OR_QUOT)) {\r\n                pos++;\r\n                return true;\r\n              }\r\n              // NOT 'ER', 'ES' OR 'ED'\r\n              if (!isOneOf(text[pos + 2], ['R', 'S', 'D'])) {\r\n                // NOT 'EL'\r\n                if (text[pos + 2] !== 'L') {\r\n                  // 'EFUL'\r\n                  if (text.substr(pos + 2, 3) === 'FUL') {\r\n                    // 'FUL'\r\n                    pos += 4;\r\n                    return true;\r\n                  }\r\n                  return false;\r\n                }\r\n                // NOT 'ELY'\r\n                if (text[pos + 3] !== 'Y') return false;\r\n                pos += 3;\r\n                return true;\r\n              }\r\n              pos += 2;\r\n              return true;\r\n            }\r\n          }[ruleByte]()) {\r\n            return false;\r\n          }\r\n        }\r\n        // Rule char does not match.\r\n        else if (text[++pos] !== ruleByte) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /**\r\n     * Test if the rule matches.\r\n     *\r\n     * @param {string} text The input text.\r\n     * @param {Number} pos  The input position we are working from.\r\n     * @return {boolean}\r\n     */\r\n    let matches = (text, pos) => {\r\n      // check if content in brackets matches.\r\n      if (!text.startsWith(match, pos)) {\r\n        return false;\r\n      }\r\n\r\n      // Check left...\r\n      if (!checkPrefix(text, pos)) {\r\n        return false;\r\n      }\r\n\r\n      // Check right...\r\n      return checkSuffix(text, pos + (match.length - 1));\r\n    };\r\n\r\n    /**\r\n     * This is the real implementation of rule processing.\r\n     *\r\n     * @param {string}          text     The text to process.\r\n     * @param {Number}          inputPos The current position in the stream.\r\n     * @param {successCallback} callback\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    let result = (text, inputPos, callback) => {\r\n      if (matches(text, inputPos)) {\r\n        {\r\n          console.log(`${source} -> ${target}`);\r\n        }\r\n        callback(target, match.length);\r\n        return true;\r\n      }\r\n    };\r\n    result.c = match[0];\r\n    return result;\r\n  };\r\n\r\n  // Map all rules and generate processors from them.\r\n  let rules = {};\r\n  rules$1.split('|').map(rule => {\r\n    let r = reciterRule(rule),\r\n      c = r.c;\r\n    rules[c] = rules[c] || [];\r\n    rules[c].push(r);\r\n  });\r\n  let rules2 = rules2$1.split('|').map(reciterRule);\r\n\r\n  /**\r\n   * Convert the text to a phoneme string.\r\n   *\r\n   * @param {string} input The input string to convert.\r\n   *\r\n   * @return {boolean|string}\r\n   */\r\n  let TextToPhonemes = input => {\r\n    let text = ' ' + input.toUpperCase();\r\n    let inputPos = 0,\r\n      output = '';\r\n    /**\r\n     * The input callback (successCallback) used from the rules.\r\n     *\r\n     * @param {string} append    The string to append.\r\n     * @param {Number} inputSkip The amount or chars to move ahead in the input.\r\n     */\r\n    let successCallback = (append, inputSkip) => {\r\n      inputPos += inputSkip;\r\n      output += append;\r\n    };\r\n    let c = 0;\r\n    while (inputPos < text.length && c++ < 10000) {\r\n      {\r\n        let tmp = text.toLowerCase();\r\n        console.log(`processing \"${tmp.substr(0, inputPos)}%c${tmp[inputPos].toUpperCase()}%c${tmp.substr(inputPos + 1)}\"`, 'color: red;', 'color:normal;');\r\n      }\r\n      let currentChar = text[inputPos];\r\n\r\n      // NOT '.' or '.' followed by number.\r\n      if (currentChar !== '.' || flagsAt(text, inputPos + 1, FLAG_NUMERIC)) {\r\n        //pos36607:\r\n        if (flags(currentChar, FLAG_RULESET2)) {\r\n          rules2.some(rule => {\r\n            return rule(text, inputPos, successCallback);\r\n          });\r\n          continue;\r\n        }\r\n        //pos36630:\r\n        if (charFlags[currentChar] !== 0) {\r\n          // pos36677:\r\n          if (!flags(currentChar, FLAG_ALPHA_OR_QUOT)) {\r\n            //36683: BRK\r\n            return false;\r\n          }\r\n          // go to the right rules for this character.\r\n          rules[currentChar].some(rule => {\r\n            return rule(text, inputPos, successCallback);\r\n          });\r\n          continue;\r\n        }\r\n        output += ' ';\r\n        inputPos++;\r\n        continue;\r\n      }\r\n      output += '.';\r\n      inputPos++;\r\n    }\r\n    return output;\r\n  };\r\n\r\n  let StressTable = '*12345678'.split('');\r\n  let PhonemeNameTable = (' *' +\r\n  // 00\r\n  '.*' +\r\n  // 01\r\n  '?*' +\r\n  // 02\r\n  ',*' +\r\n  // 03\r\n  '-*' +\r\n  // 04\r\n  'IY' +\r\n  // 05\r\n  'IH' +\r\n  // 06\r\n  'EH' +\r\n  // 07\r\n  'AE' +\r\n  // 08\r\n  'AA' +\r\n  // 09\r\n  'AH' +\r\n  // 10\r\n  'AO' +\r\n  // 11\r\n  'UH' +\r\n  // 12\r\n  'AX' +\r\n  // 13\r\n  'IX' +\r\n  // 14\r\n  'ER' +\r\n  // 15\r\n  'UX' +\r\n  // 16\r\n  'OH' +\r\n  // 17\r\n  'RX' +\r\n  // 18\r\n  'LX' +\r\n  // 19\r\n  'WX' +\r\n  // 20\r\n  'YX' +\r\n  // 21\r\n  'WH' +\r\n  // 22\r\n  'R*' +\r\n  // 23\r\n  'L*' +\r\n  // 24\r\n  'W*' +\r\n  // 25\r\n  'Y*' +\r\n  // 26\r\n  'M*' +\r\n  // 27\r\n  'N*' +\r\n  // 28\r\n  'NX' +\r\n  // 29\r\n  'DX' +\r\n  // 30\r\n  'Q*' +\r\n  // 31\r\n  'S*' +\r\n  // 32\r\n  'SH' +\r\n  // 33\r\n  'F*' +\r\n  // 34\r\n  'TH' +\r\n  // 35\r\n  '/H' +\r\n  // 36\r\n  '/X' +\r\n  // 37\r\n  'Z*' +\r\n  // 38\r\n  'ZH' +\r\n  // 39\r\n  'V*' +\r\n  // 40\r\n  'DH' +\r\n  // 41\r\n  'CH' +\r\n  // 42\r\n  '**' +\r\n  // 43\r\n  'J*' +\r\n  // 44\r\n  '**' +\r\n  // 45\r\n  '**' +\r\n  // 46\r\n  '**' +\r\n  // 47\r\n  'EY' +\r\n  // 48\r\n  'AY' +\r\n  // 49\r\n  'OY' +\r\n  // 50\r\n  'AW' +\r\n  // 51\r\n  'OW' +\r\n  // 52\r\n  'UW' +\r\n  // 53\r\n  'B*' +\r\n  // 54\r\n  '**' +\r\n  // 55\r\n  '**' +\r\n  // 56\r\n  'D*' +\r\n  // 57\r\n  '**' +\r\n  // 58\r\n  '**' +\r\n  // 59\r\n  'G*' +\r\n  // 60\r\n  '**' +\r\n  // 61\r\n  '**' +\r\n  // 62\r\n  'GX' +\r\n  // 63\r\n  '**' +\r\n  // 64\r\n  '**' +\r\n  // 65\r\n  'P*' +\r\n  // 66\r\n  '**' +\r\n  // 67\r\n  '**' +\r\n  // 68\r\n  'T*' +\r\n  // 69\r\n  '**' +\r\n  // 70\r\n  '**' +\r\n  // 71\r\n  'K*' +\r\n  // 72\r\n  '**' +\r\n  // 73\r\n  '**' +\r\n  // 74\r\n  'KX' +\r\n  // 75\r\n  '**' +\r\n  // 76\r\n  '**' +\r\n  // 77\r\n  'UL' +\r\n  // 78\r\n  'UM' +\r\n  // 79\r\n  'UN' // 80\r\n  ).match(/.{1,2}/g);\r\n\r\n  /**\r\n   * Flags for phoneme names.\r\n   *\r\n   * Merged from the original two tables via: oldFlags[i] | (oldFlags2[i] << 8)\r\n   *\r\n   *  0x8000\r\n   *    ' *', '.*', '?*', ',*', '-*'\r\n   *  0x4000\r\n   *    '.*', '?*', ',*', '-*', 'Q*'\r\n   *  0x2000  FLAG_FRICATIVE\r\n   *    'S*', 'SH', 'F*', 'TH', 'Z*', 'ZH', 'V*', 'DH', 'CH', '**', '**'\r\n   *  0x1000  FLAG_LIQUIC\r\n   *    'R*', 'L*', 'W*', 'Y*'\r\n   *  0x0800  FLAG_NASAL\r\n   *    'M*', 'N*', 'NX'\r\n   *  0x0400  FLAG_ALVEOLAR\r\n   *    'N*', 'DX', 'S*', 'TH', 'Z*', 'DH', 'D*', '**', '**', 'T*', '**',\r\n   *    '**'\r\n   *  0x0200\r\n   *    --- not used ---\r\n   *  0x0100  FLAG_PUNCT\r\n   *    '.*', '?*', ',*', '-*'\r\n   *  0x0080  FLAG_VOWEL\r\n   *    'IY', 'IH', 'EH', 'AE', 'AA', 'AH', 'AO', 'UH', 'AX', 'IX', 'ER',\r\n   *    'UX', 'OH', 'RX', 'LX', 'WX', 'YX', 'EY', 'AY', 'OY', 'AW', 'OW',\r\n   *    'UW', 'UL', 'UM', 'UN'\r\n   *  0x0040  FLAG_CONSONANT\r\n   *    'WH', 'R*', 'L*', 'W*', 'Y*', 'M*', 'N*', 'NX', 'DX', 'Q*', 'S*',\r\n   *    'SH', 'F*', 'TH', '/H', '/X', 'Z*', 'ZH', 'V*', 'DH', 'CH', '**',\r\n   *    'J*', '**', 'B*', '**', '**', 'D*', '**', '**', 'G*', '**', '**',\r\n   *    'GX', '**', '**', 'P*', '**', '**', 'T*', '**', '**', 'K*', '**',\r\n   *    '**', 'KX', '**', '**', 'UM', 'UN'\r\n   *  0x0020  FLAG_DIP_YX  but looks like front vowels\r\n   *    'IY', 'IH', 'EH', 'AE', 'AA', 'AH', 'AX', 'IX', 'EY', 'AY', 'OY'\r\n   *  0x0010  FLAG_DIPHTHONG\r\n   *    'EY', 'AY', 'OY', 'AW', 'OW', 'UW'\r\n   *  0x0008\r\n   *    'M*', 'N*', 'NX', 'DX', 'Q*', 'CH', 'J*', 'B*', '**', '**', 'D*',\r\n   *    '**', '**', 'G*', '**', '**', 'GX', '**', '**', 'P*', '**', '**',\r\n   *    'T*', '**', '**', 'K*', '**', '**', 'KX', '**', '**'\r\n   *  0x0004  FLAG_VOICED\r\n   *    'IY', 'IH', 'EH', 'AE', 'AA', 'AH', 'AO', 'UH', 'AX', 'IX', 'ER',\r\n   *    'UX', 'OH', 'RX', 'LX', 'WX', 'YX', 'WH', 'R*', 'L*', 'W*', 'Y*',\r\n   *    'M*', 'N*', 'NX', 'Q*', 'Z*', 'ZH', 'V*', 'DH', 'J*', '**', 'EY',\r\n   *    'AY', 'OY', 'AW', 'OW', 'UW', 'B*', '**', '**', 'D*', '**', '**',\r\n   *    'G*', '**', '**', 'GX', '**', '**'\r\n   *  0x0002  FLAG_STOPCONS\r\n   *    'B*', '**', '**', 'D*', '**', '**', 'G*', '**', '**', 'GX', '**',\r\n   *    '**', 'P*', '**', '**', 'T*', '**', '**', 'K*', '**', '**', 'KX',\r\n   *    '**', '**'\r\n   *  0x0001  FLAG_UNVOICED_STOPCONS\r\n   *    'P*', '**', '**', 'T*', '**', '**', 'K*', '**', '**', 'KX', '**',\r\n   *    '**', 'UM', 'UN'\r\n   */\r\n  let phonemeFlags = [0 | 0x8000,\r\n  // ' *' 00\r\n  0 | 0x8000 | 0x4000 | 0x0100,\r\n  // '.*' 01\r\n  0 | 0x8000 | 0x4000 | 0x0100,\r\n  // '?*' 02\r\n  0 | 0x8000 | 0x4000 | 0x0100,\r\n  // ',*' 03\r\n  0 | 0x8000 | 0x4000 | 0x0100,\r\n  // '-*' 04\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'IY' 05\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'IH' 06\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'EH' 07\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'AE' 08\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'AA' 09\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'AH' 10\r\n  0 | 0x0080 | 0x0004,\r\n  // 'AO' 11\r\n  0 | 0x0080 | 0x0004,\r\n  // 'UH' 12\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'AX' 13\r\n  0 | 0x0080 | 0x0020 | 0x0004,\r\n  // 'IX' 14\r\n  0 | 0x0080 | 0x0004,\r\n  // 'ER' 15\r\n  0 | 0x0080 | 0x0004,\r\n  // 'UX' 16\r\n  0 | 0x0080 | 0x0004,\r\n  // 'OH' 17\r\n  0 | 0x0080 | 0x0004,\r\n  // 'RX' 18\r\n  0 | 0x0080 | 0x0004,\r\n  // 'LX' 19\r\n  0 | 0x0080 | 0x0004,\r\n  // 'WX' 20\r\n  0 | 0x0080 | 0x0004,\r\n  // 'YX' 21\r\n  0 | 0x0040 | 0x0004,\r\n  // 'WH' 22\r\n  0 | 0x1000 | 0x0040 | 0x0004,\r\n  // 'R*' 23\r\n  0 | 0x1000 | 0x0040 | 0x0004,\r\n  // 'L*' 24\r\n  0 | 0x1000 | 0x0040 | 0x0004,\r\n  // 'W*' 25\r\n  0 | 0x1000 | 0x0040 | 0x0004,\r\n  // 'Y*' 26\r\n  0 | 0x0800 | 0x0040 | 0x0008 | 0x0004,\r\n  // 'M*' 27\r\n  0 | 0x0800 | 0x0400 | 0x0040 | 0x0008 | 0x0004,\r\n  // 'N*' 28\r\n  0 | 0x0800 | 0x0040 | 0x0008 | 0x0004,\r\n  // 'NX' 29\r\n  0 | 0x0400 | 0x0040 | 0x0008,\r\n  // 'DX' 30\r\n  0 | 0x4000 | 0x0040 | 0x0008 | 0x0004,\r\n  // 'Q*' 31\r\n  0 | 0x2000 | 0x0400 | 0x0040,\r\n  // 'S*' 32\r\n  0 | 0x2000 | 0x0040,\r\n  // 'SH' 33\r\n  0 | 0x2000 | 0x0040,\r\n  // 'F*' 34\r\n  0 | 0x2000 | 0x0400 | 0x0040,\r\n  // 'TH' 35\r\n  0 | 0x0040,\r\n  // '/H' 36\r\n  0 | 0x0040,\r\n  // '/X' 37\r\n  0 | 0x2000 | 0x0400 | 0x0040 | 0x0004,\r\n  // 'Z*' 38\r\n  0 | 0x2000 | 0x0040 | 0x0004,\r\n  // 'ZH' 39\r\n  0 | 0x2000 | 0x0040 | 0x0004,\r\n  // 'V*' 40\r\n  0 | 0x2000 | 0x0400 | 0x0040 | 0x0004,\r\n  // 'DH' 41\r\n  0 | 0x2000 | 0x0040 | 0x0008,\r\n  // 'CH' 42\r\n  0 | 0x2000 | 0x0040,\r\n  // '**' 43\r\n  0 | 0x0040 | 0x0008 | 0x0004,\r\n  // 'J*' 44\r\n  0 | 0x2000 | 0x0040 | 0x0004,\r\n  // '**' 45\r\n  0,\r\n  // '**' 46\r\n  0,\r\n  // '**' 47\r\n  0 | 0x0080 | 0x0020 | 0x0010 | 0x0004,\r\n  // 'EY' 48\r\n  0 | 0x0080 | 0x0020 | 0x0010 | 0x0004,\r\n  // 'AY' 49\r\n  0 | 0x0080 | 0x0020 | 0x0010 | 0x0004,\r\n  // 'OY' 50\r\n  0 | 0x0080 | 0x0010 | 0x0004,\r\n  // 'AW' 51\r\n  0 | 0x0080 | 0x0010 | 0x0004,\r\n  // 'OW' 52\r\n  0 | 0x0080 | 0x0010 | 0x0004,\r\n  // 'UW' 53\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // 'B*' 54\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 55\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 56\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // 'D*' 57\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 58\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 59\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // 'G*' 60\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 61\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 62\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // 'GX' 63\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 64\r\n  0 | 0x0040 | 0x0008 | 0x0004 | 0x0002,\r\n  // '**' 65\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // 'P*' 66\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 67\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 68\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // 'T*' 69\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 70\r\n  0 | 0x0400 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 71\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // 'K*' 72\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 73\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 74\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // 'KX' 75\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 76\r\n  0 | 0x0040 | 0x0008 | 0x0002 | 0x0001,\r\n  // '**' 77\r\n  0 | 0x0080,\r\n  // 'UL' 78\r\n  0 | 0x0080 | 0x0040 | 0x0001,\r\n  // 'UM' 79\r\n  0 | 0x0080 | 0x0040 | 0x0001 // 'UN' 80\r\n  ];\r\n\r\n  /**\r\n   * Combined table of phoneme length.\r\n   *\r\n   * Merged from the original two tables via: phonemeLengthTable[i] | (phonemeStressedLengthTable[i] << 8)\r\n   *\r\n   * Use via:\r\n   *  phonemeLengthTable[i] = combinedPhonemeLengthTable[i] & 0xFF\r\n   *  phonemeStressedLengthTable[i] = combinedPhonemeLengthTable[i] >> 8\r\n   */\r\n  let combinedPhonemeLengthTable = [0x0000 | 0x0000,\r\n  // ' *' 00\r\n  0x0012 | 0x1200,\r\n  // '.*' 01\r\n  0x0012 | 0x1200,\r\n  // '?*' 02\r\n  0x0012 | 0x1200,\r\n  // ',*' 03\r\n  0x0008 | 0x0800,\r\n  // '-*' 04\r\n  0x0008 | 0x0B00,\r\n  // 'IY' 05\r\n  0x0008 | 0x0900,\r\n  // 'IH' 06\r\n  0x0008 | 0x0B00,\r\n  // 'EH' 07\r\n  0x0008 | 0x0E00,\r\n  // 'AE' 08\r\n  0x000B | 0x0F00,\r\n  // 'AA' 09\r\n  0x0006 | 0x0B00,\r\n  // 'AH' 10\r\n  0x000C | 0x1000,\r\n  // 'AO' 11\r\n  0x000A | 0x0C00,\r\n  // 'UH' 12\r\n  0x0005 | 0x0600,\r\n  // 'AX' 13\r\n  0x0005 | 0x0600,\r\n  // 'IX' 14\r\n  0x000B | 0x0E00,\r\n  // 'ER' 15\r\n  0x000A | 0x0C00,\r\n  // 'UX' 16\r\n  0x000A | 0x0E00,\r\n  // 'OH' 17\r\n  0x000A | 0x0C00,\r\n  // 'RX' 18\r\n  0x0009 | 0x0B00,\r\n  // 'LX' 19\r\n  0x0008 | 0x0800,\r\n  // 'WX' 20\r\n  0x0007 | 0x0800,\r\n  // 'YX' 21\r\n  0x0009 | 0x0B00,\r\n  // 'WH' 22\r\n  0x0007 | 0x0A00,\r\n  // 'R*' 23\r\n  0x0006 | 0x0900,\r\n  // 'L*' 24\r\n  0x0008 | 0x0800,\r\n  // 'W*' 25\r\n  0x0006 | 0x0800,\r\n  // 'Y*' 26\r\n  0x0007 | 0x0800,\r\n  // 'M*' 27\r\n  0x0007 | 0x0800,\r\n  // 'N*' 28\r\n  0x0007 | 0x0800,\r\n  // 'NX' 29\r\n  0x0002 | 0x0300,\r\n  // 'DX' 30\r\n  0x0005 | 0x0500,\r\n  // 'Q*' 31\r\n  0x0002 | 0x0200,\r\n  // 'S*' 32\r\n  0x0002 | 0x0200,\r\n  // 'SH' 33\r\n  0x0002 | 0x0200,\r\n  // 'F*' 34\r\n  0x0002 | 0x0200,\r\n  // 'TH' 35\r\n  0x0002 | 0x0200,\r\n  // '/H' 36\r\n  0x0002 | 0x0200,\r\n  // '/X' 37\r\n  0x0006 | 0x0600,\r\n  // 'Z*' 38\r\n  0x0006 | 0x0600,\r\n  // 'ZH' 39\r\n  0x0007 | 0x0800,\r\n  // 'V*' 40\r\n  0x0006 | 0x0600,\r\n  // 'DH' 41\r\n  0x0006 | 0x0600,\r\n  // 'CH' 42\r\n  0x0002 | 0x0200,\r\n  // '**' 43\r\n  0x0008 | 0x0900,\r\n  // 'J*' 44\r\n  0x0003 | 0x0400,\r\n  // '**' 45\r\n  0x0001 | 0x0200,\r\n  // '**' 46\r\n  0x001E | 0x0100,\r\n  // '**' 47\r\n  0x000D | 0x0E00,\r\n  // 'EY' 48\r\n  0x000C | 0x0F00,\r\n  // 'AY' 49\r\n  0x000C | 0x0F00,\r\n  // 'OY' 50\r\n  0x000C | 0x0F00,\r\n  // 'AW' 51\r\n  0x000E | 0x0E00,\r\n  // 'OW' 52\r\n  0x0009 | 0x0E00,\r\n  // 'UW' 53\r\n  0x0006 | 0x0800,\r\n  // 'B*' 54\r\n  0x0001 | 0x0200,\r\n  // '**' 55\r\n  0x0002 | 0x0200,\r\n  // '**' 56\r\n  0x0005 | 0x0700,\r\n  // 'D*' 57\r\n  0x0001 | 0x0200,\r\n  // '**' 58\r\n  0x0001 | 0x0100,\r\n  // '**' 59\r\n  0x0006 | 0x0700,\r\n  // 'G*' 60\r\n  0x0001 | 0x0200,\r\n  // '**' 61\r\n  0x0002 | 0x0200,\r\n  // '**' 62\r\n  0x0006 | 0x0700,\r\n  // 'GX' 63\r\n  0x0001 | 0x0200,\r\n  // '**' 64\r\n  0x0002 | 0x0200,\r\n  // '**' 65\r\n  0x0008 | 0x0800,\r\n  // 'P*' 66\r\n  0x0002 | 0x0200,\r\n  // '**' 67\r\n  0x0002 | 0x0200,\r\n  // '**' 68\r\n  0x0004 | 0x0600,\r\n  // 'T*' 69\r\n  0x0002 | 0x0200,\r\n  // '**' 70\r\n  0x0002 | 0x0200,\r\n  // '**' 71\r\n  0x0006 | 0x0700,\r\n  // 'K*' 72\r\n  0x0001 | 0x0200,\r\n  // '**' 73\r\n  0x0004 | 0x0400,\r\n  // '**' 74\r\n  0x0006 | 0x0700,\r\n  // 'KX' 75\r\n  0x0001 | 0x0100,\r\n  // '**' 76\r\n  0x0004 | 0x0400,\r\n  // '**' 77\r\n  0x00C7 | 0x0500,\r\n  // 'UL' 78\r\n  0x00FF | 0x0500 // 'UM' 79\r\n  ];\r\n\r\n  /*\r\n\r\n  Ind  | phoneme |  flags   |\r\n  -----|---------|----------|\r\n  0    |   *     | 00000000 |\r\n  1    |  .*     | 00000000 |\r\n  2    |  ?*     | 00000000 |\r\n  3    |  ,*     | 00000000 |\r\n  4    |  -*     | 00000000 |\r\n\r\n  VOWELS\r\n  5    |  IY     | 10100100 |\r\n  6    |  IH     | 10100100 |\r\n  7    |  EH     | 10100100 |\r\n  8    |  AE     | 10100100 |\r\n  9    |  AA     | 10100100 |\r\n  10   |  AH     | 10100100 |\r\n  11   |  AO     | 10000100 |\r\n  17   |  OH     | 10000100 |\r\n  12   |  UH     | 10000100 |\r\n  16   |  UX     | 10000100 |\r\n  15   |  ER     | 10000100 |\r\n  13   |  AX     | 10100100 |\r\n  14   |  IX     | 10100100 |\r\n\r\n  DIPHTONGS\r\n  48   |  EY     | 10110100 |\r\n  49   |  AY     | 10110100 |\r\n  50   |  OY     | 10110100 |\r\n  51   |  AW     | 10010100 |\r\n  52   |  OW     | 10010100 |\r\n  53   |  UW     | 10010100 |\r\n\r\n\r\n  21   |  YX     | 10000100 |\r\n  20   |  WX     | 10000100 |\r\n  18   |  RX     | 10000100 |\r\n  19   |  LX     | 10000100 |\r\n  37   |  /X     | 01000000 |\r\n  30   |  DX     | 01001000 |\r\n\r\n\r\n  22   |  WH     | 01000100 |\r\n\r\n\r\n  VOICED CONSONANTS\r\n  23   |  R*     | 01000100 |\r\n  24   |  L*     | 01000100 |\r\n  25   |  W*     | 01000100 |\r\n  26   |  Y*     | 01000100 |\r\n  27   |  M*     | 01001100 |\r\n  28   |  N*     | 01001100 |\r\n  29   |  NX     | 01001100 |\r\n  54   |  B*     | 01001110 |\r\n  57   |  D*     | 01001110 |\r\n  60   |  G*     | 01001110 |\r\n  44   |  J*     | 01001100 |\r\n  38   |  Z*     | 01000100 |\r\n  39   |  ZH     | 01000100 |\r\n  40   |  V*     | 01000100 |\r\n  41   |  DH     | 01000100 |\r\n\r\n  unvoiced CONSONANTS\r\n  32   |  S*     | 01000000 |\r\n  33   |  SH     | 01000000 |\r\n  34   |  F*     | 01000000 |\r\n  35   |  TH     | 01000000 |\r\n  66   |  P*     | 01001011 |\r\n  69   |  T*     | 01001011 |\r\n  72   |  K*     | 01001011 |\r\n  42   |  CH     | 01001000 |\r\n  36   |  /H     | 01000000 |\r\n\r\n  43   |  **     | 01000000 |\r\n  45   |  **     | 01000100 |\r\n  46   |  **     | 00000000 |\r\n  47   |  **     | 00000000 |\r\n\r\n\r\n  55   |  **     | 01001110 |\r\n  56   |  **     | 01001110 |\r\n  58   |  **     | 01001110 |\r\n  59   |  **     | 01001110 |\r\n  61   |  **     | 01001110 |\r\n  62   |  **     | 01001110 |\r\n  63   |  GX     | 01001110 |\r\n  64   |  **     | 01001110 |\r\n  65   |  **     | 01001110 |\r\n  67   |  **     | 01001011 |\r\n  68   |  **     | 01001011 |\r\n  70   |  **     | 01001011 |\r\n  71   |  **     | 01001011 |\r\n  73   |  **     | 01001011 |\r\n  74   |  **     | 01001011 |\r\n  75   |  KX     | 01001011 |\r\n  76   |  **     | 01001011 |\r\n  77   |  **     | 01001011 |\r\n\r\n\r\n  SPECIAL\r\n  78   |  UL     | 10000000 |\r\n  79   |  UM     | 11000001 |\r\n  80   |  UN     | 11000001 |\r\n  31   |  Q*     | 01001100 |\r\n\r\n  */\r\n\r\n  /**\r\n   * Match two character phoneme.\r\n   *\r\n   * @param {string} sign1\r\n   * @param {string} sign2\r\n   * @return {boolean|Number}\r\n   */\r\n  let full_match = (sign1, sign2) => {\r\n    let index = PhonemeNameTable.findIndex(value => {\r\n      return value === sign1 + sign2 && value[1] !== '*';\r\n    });\r\n    return index !== -1 ? index : false;\r\n  };\r\n\r\n  /**\r\n   * Match single character phoneme.\r\n   *\r\n   * @param {string} sign1\r\n   * @return {boolean|Number}\r\n   */\r\n  let single_match = sign1 => {\r\n    let index = PhonemeNameTable.findIndex(value => {\r\n      return value === sign1 + '*';\r\n    });\r\n    return index !== -1 ? index : false;\r\n  };\r\n\r\n  /**\r\n   * The input[] buffer contains a string of phonemes and stress markers along\r\n   * the lines of:\r\n   *\r\n   *     DHAX KAET IHZ AH5GLIY.\r\n   *\r\n   * Some phonemes are 2 bytes long, such as \"DH\" and \"AX\".\r\n   * Others are 1 byte long, such as \"T\" and \"Z\".\r\n   * There are also stress markers, such as \"5\" and \".\".\r\n   *\r\n   * The characters of the phonemes are stored in the table PhonemeNameTable.\r\n   * The stress characters are arranged in low to high stress order in StressTable[].\r\n   *\r\n   * The following process is used to parse the input buffer:\r\n   *\r\n   * Repeat until the end is reached:\r\n   * 1. First, a search is made for a 2 character match for phonemes that do not\r\n   *    end with the '*' (single char mark) character. On a match, the index of the phoneme\r\n   *    is added to the result and the buffer position is advanced 2 bytes.\r\n   *\r\n   * 2. If this fails, a search is made for a 1 character match against all\r\n   *    phoneme names ending with a '*' (single char mark). If this succeeds, the\r\n   *    phoneme is added to result and the buffer position is advanced\r\n   *    1 byte.\r\n   *\r\n   * 3. If this fails, search for a 1 character match in the stressInputTable[].\r\n   *   If this succeeds, the stress value is placed in the last stress[] table\r\n   *   at the same index of the last added phoneme, and the buffer position is\r\n   *   advanced by 1 byte.\r\n   *\r\n   * If this fails, return false.\r\n   *\r\n   * On success:\r\n   *\r\n   *    1. phonemeIndex[] will contain the index of all the phonemes.\r\n   *    2. The last index in phonemeIndex[] will be 255.\r\n   *    3. stress[] will contain the stress value for each phoneme\r\n   *\r\n   * input holds the string of phonemes, each two bytes wide\r\n   * signInputTable1[] holds the first character of each phoneme\r\n   * signInputTable2[] holds the second character of each phoneme\r\n   * phonemeIndex[] holds the indexes of the phonemes after parsing input[]\r\n   *\r\n   * The parser scans through the input[], finding the names of the phonemes\r\n   * by searching signInputTable1[] and signInputTable2[]. On a match, it\r\n   * copies the index of the phoneme into the phonemeIndexTable[].\r\n   *\r\n   * @param {string}   input      Holds the string of phonemes, each two bytes wide.\r\n   * @param {function} addPhoneme The callback to use to store phoneme index values.\r\n   * @param {function} addStress  The callback to use to store stress index values.\r\n   *\r\n   * @return {undefined}\r\n   */\r\n  let Parser1 = (input, addPhoneme, addStress) => {\r\n    for (let srcPos = 0; srcPos < input.length; srcPos++) {\r\n      {\r\n        let tmp = input.toLowerCase();\r\n        console.log(`processing \"${tmp.substr(0, srcPos)}%c${tmp.substr(srcPos, 2).toUpperCase()}%c${tmp.substr(srcPos + 2)}\"`, 'color: red;', 'color:normal;');\r\n      }\r\n      let sign1 = input[srcPos];\r\n      let sign2 = input[srcPos + 1] || '';\r\n      let match;\r\n      if ((match = full_match(sign1, sign2)) !== false) {\r\n        // Matched both characters (no single char mark)\r\n        srcPos++; // Skip the second character of the input as we've matched it\r\n        addPhoneme(match);\r\n        continue;\r\n      }\r\n      if ((match = single_match(sign1)) !== false) {\r\n        // Matched just the first character (with second character matching '*'\r\n        addPhoneme(match);\r\n        continue;\r\n      }\r\n\r\n      // Should be a stress character. Search through the stress table backwards.\r\n      match = StressTable.length;\r\n      while (sign1 !== StressTable[match] && match > 0) {\r\n        --match;\r\n      }\r\n      if (match === 0) {\r\n        {\r\n          throw Error(`Could not parse char ${sign1}`);\r\n        }\r\n      }\r\n      addStress(match); // Set stress for prior phoneme\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Test if a phoneme has the given flag.\r\n   *\r\n   * @param {Number} phoneme The phoneme to test.\r\n   * @param {Number} flag    The flag to test (see constants.es6)\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  let phonemeHasFlag = (phoneme, flag) => {\r\n    return matchesBitmask(phonemeFlags[phoneme], flag);\r\n  };\r\n\r\n  let pR = 23;\r\n  let pD = 57;\r\n  let pT = 69;\r\n  let PHONEME_PERIOD = 1;\r\n  let PHONEME_QUESTION = 2;\r\n  let FLAG_FRICATIVE = 0x2000;\r\n\r\n  /**\r\n   * liquic consonant\r\n   */\r\n  let FLAG_LIQUIC = 0x1000;\r\n  let FLAG_NASAL = 0x0800;\r\n  let FLAG_ALVEOLAR = 0x0400;\r\n  let FLAG_PUNCT = 0x0100;\r\n  let FLAG_VOWEL = 0x0080;\r\n  let FLAG_CONSONANT = 0x0040;\r\n  /**\r\n   *  diphthong ending with YX\r\n   *\r\n   */\r\n  let FLAG_DIP_YX = 0x0020;\r\n  let FLAG_DIPHTHONG = 0x0010;\r\n  /** unknown:\r\n   *    'M*', 'N*', 'NX', 'DX', 'Q*', 'CH', 'J*', 'B*', '**', '**', 'D*',\r\n   *    '**', '**', 'G*', '**', '**', 'GX', '**', '**', 'P*', '**', '**',\r\n   *    'T*', '**', '**', 'K*', '**', '**', 'KX', '**', '**'\r\n   */\r\n  let FLAG_0008 = 0x0008;\r\n  let FLAG_VOICED = 0x0004;\r\n\r\n  /**\r\n   * stop consonant\r\n   */\r\n  let FLAG_STOPCONS = 0x0002;\r\n  let FLAG_UNVOICED_STOPCONS = 0x0001;\r\n\r\n  /**\r\n   * Rewrites the phonemes using the following rules:\r\n   *\r\n   * <DIPHTHONG ENDING WITH WX> -> <DIPHTHONG ENDING WITH WX> WX\r\n   * <DIPHTHONG NOT ENDING WITH WX> -> <DIPHTHONG NOT ENDING WITH WX> YX\r\n   * UL -> AX L\r\n   * UM -> AX M\r\n   * UN -> AX N\r\n   * <STRESSED VOWEL> <SILENCE> <STRESSED VOWEL> -> <STRESSED VOWEL> <SILENCE> Q <VOWEL>\r\n   * T R -> CH R\r\n   * D R -> J R\r\n   * <VOWEL> R -> <VOWEL> RX\r\n   * <VOWEL> L -> <VOWEL> LX\r\n   * G S -> G Z\r\n   * K <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>\r\n   * G <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> GX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>\r\n   * S P -> S B\r\n   * S T -> S D\r\n   * S K -> S G\r\n   * S KX -> S GX\r\n   * <ALVEOLAR> UW -> <ALVEOLAR> UX\r\n   * CH -> CH CH' (CH requires two phonemes to represent it)\r\n   * J -> J J' (J requires two phonemes to represent it)\r\n   * <UNSTRESSED VOWEL> T <PAUSE> -> <UNSTRESSED VOWEL> DX <PAUSE>\r\n   * <UNSTRESSED VOWEL> D <PAUSE>  -> <UNSTRESSED VOWEL> DX <PAUSE>\r\n   *\r\n   * @param {insertPhoneme}    insertPhoneme\r\n   * @param {setPhoneme}       setPhoneme\r\n   * @param {getPhoneme}       getPhoneme\r\n   * @param {getPhonemeStress} getStress\r\n   *\r\n   * @return undefined\r\n   */\r\n  let Parser2 = (insertPhoneme, setPhoneme, getPhoneme, getStress) => {\r\n    /**\r\n     * Rewrites:\r\n     *  'UW' => 'UX' if alveolar flag set on previous phoneme.\r\n     *  'CH' => 'CH' '**'(43)\r\n     *  'J*' => 'J*' '**'(45)\r\n     * @param phoneme\r\n     * @param pos\r\n     */\r\n    let handleUW_CH_J = (phoneme, pos) => {\r\n      switch (phoneme) {\r\n        // 'UW' Example: NEW, DEW, SUE, ZOO, THOO, TOO\r\n        case 53:\r\n          {\r\n            // ALVEOLAR flag set?\r\n            if (phonemeHasFlag(getPhoneme(pos - 1), FLAG_ALVEOLAR)) {\r\n              {\r\n                console.log(`${pos} RULE: <ALVEOLAR> UW -> <ALVEOLAR> UX`);\r\n              }\r\n              setPhoneme(pos, 16); // UX\r\n            }\r\n            break;\r\n          }\r\n        // 'CH' Example: CHEW\r\n        case 42:\r\n          {\r\n            {\r\n              console.log(`${pos} RULE: CH -> CH CH+1`);\r\n            }\r\n            insertPhoneme(pos + 1, 43, getStress(pos)); // '**'\r\n            break;\r\n          }\r\n        // 'J*' Example: JAY\r\n        case 44:\r\n          {\r\n            {\r\n              console.log(`${pos} RULE: J -> J J+1`);\r\n            }\r\n            insertPhoneme(pos + 1, 45, getStress(pos)); // '**'\r\n            break;\r\n          }\r\n      }\r\n    };\r\n    let changeAX = (position, suffix) => {\r\n      {\r\n        console.log(`${position} RULE: ${PhonemeNameTable[getPhoneme(position)]} -> AX ${PhonemeNameTable[suffix]}`);\r\n      }\r\n      setPhoneme(position, 13); // 'AX'\r\n      insertPhoneme(position + 1, suffix, getStress(position));\r\n    };\r\n    let pos = -1;\r\n    let phoneme;\r\n    while ((phoneme = getPhoneme(++pos)) !== null) {\r\n      // Is phoneme pause?\r\n      if (phoneme === 0) {\r\n        continue;\r\n      }\r\n      if (phonemeHasFlag(phoneme, FLAG_DIPHTHONG)) {\r\n        // <DIPHTHONG ENDING WITH WX> -> <DIPHTHONG ENDING WITH WX> WX\r\n        // <DIPHTHONG NOT ENDING WITH WX> -> <DIPHTHONG NOT ENDING WITH WX> YX\r\n        // Example: OIL, COW\r\n        {\r\n          console.log(!phonemeHasFlag(phoneme, FLAG_DIP_YX) ? `${pos} RULE: insert WX following diphthong NOT ending in IY sound` : `${pos} RULE: insert YX following diphthong ending in IY sound`);\r\n        }\r\n        // If ends with IY, use YX, else use WX\r\n        // Insert at WX or YX following, copying the stress\r\n        // 'WX' = 20 'YX' = 21\r\n        insertPhoneme(pos + 1, phonemeHasFlag(phoneme, FLAG_DIP_YX) ? 21 : 20, getStress(pos));\r\n        handleUW_CH_J(phoneme, pos);\r\n        continue;\r\n      }\r\n      if (phoneme === 78) {\r\n        // 'UL' => 'AX' 'L*'\r\n        // Example: MEDDLE\r\n        changeAX(pos, 24);\r\n        continue;\r\n      }\r\n      if (phoneme === 79) {\r\n        // 'UM' => 'AX' 'M*'\r\n        // Example: ASTRONOMY\r\n        changeAX(pos, 27);\r\n        continue;\r\n      }\r\n      if (phoneme === 80) {\r\n        // 'UN' => 'AX' 'N*'\r\n        changeAX(pos, 28);\r\n        continue;\r\n      }\r\n      if (phonemeHasFlag(phoneme, FLAG_VOWEL) && getStress(pos)) {\r\n        // Example: FUNCTION\r\n        // RULE:\r\n        //       <STRESSED VOWEL> <SILENCE> <STRESSED VOWEL> -> <STRESSED VOWEL> <SILENCE> Q <VOWEL>\r\n        // EXAMPLE: AWAY EIGHT\r\n        if (getPhoneme(pos + 1) === 0) {\r\n          // If following phoneme is a pause, get next\r\n          phoneme = getPhoneme(pos + 2);\r\n          if (phoneme !== null && phonemeHasFlag(phoneme, FLAG_VOWEL) && getStress(pos + 2)) {\r\n            {\r\n              console.log(`${pos + 2} RULE: Insert glottal stop between two stressed vowels with space between them`);\r\n            }\r\n            insertPhoneme(pos + 2, 31, 0); // 31 = 'Q'\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n      let priorPhoneme = pos === 0 ? null : getPhoneme(pos - 1);\r\n      if (phoneme === pR) {\r\n        // RULES FOR PHONEMES BEFORE R\r\n        switch (priorPhoneme) {\r\n          case pT:\r\n            {\r\n              // Example: TRACK\r\n              {\r\n                console.log(`${pos} RULE: T* R* -> CH R*`);\r\n              }\r\n              setPhoneme(pos - 1, 42); // 'T*' 'R*' -> 'CH' 'R*'\r\n              break;\r\n            }\r\n          case pD:\r\n            {\r\n              // Example: DRY\r\n              {\r\n                console.log(`${pos} RULE: D* R* -> J* R*`);\r\n              }\r\n              setPhoneme(pos - 1, 44); // 'J*'\r\n              break;\r\n            }\r\n          default:\r\n            {\r\n              if (phonemeHasFlag(priorPhoneme, FLAG_VOWEL)) {\r\n                // Example: ART\r\n                {\r\n                  console.log(`${pos} <VOWEL> R* -> <VOWEL> RX`);\r\n                }\r\n                setPhoneme(pos, 18); // 'RX'\r\n              }\r\n            }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // 'L*'\r\n      if (phoneme === 24 && phonemeHasFlag(priorPhoneme, FLAG_VOWEL)) {\r\n        // Example: ALL\r\n        {\r\n          console.log(`${pos} <VOWEL> L* -> <VOWEL> LX`);\r\n        }\r\n        setPhoneme(pos, 19); // 'LX'\r\n        continue;\r\n      }\r\n      // 'G*' 'S*'\r\n      if (priorPhoneme === 60 && phoneme === 32) {\r\n        // Can't get to fire -\r\n        //       1. The G -> GX rule intervenes\r\n        //       2. Reciter already replaces GS -> GZ\r\n        {\r\n          console.log(`${pos} G S -> G Z`);\r\n        }\r\n        setPhoneme(pos, 38);\r\n        continue;\r\n      }\r\n\r\n      // 'G*'\r\n      if (phoneme === 60) {\r\n        // G <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> GX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>\r\n        // Example: GO\r\n        let phoneme = getPhoneme(pos + 1);\r\n        // If diphthong ending with YX, move continue processing next phoneme\r\n        if (!phonemeHasFlag(phoneme, FLAG_DIP_YX) && phoneme !== null) {\r\n          // replace G with GX and continue processing next phoneme\r\n          {\r\n            console.log(`${pos} RULE: G <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> GX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>`);\r\n          }\r\n          setPhoneme(pos, 63); // 'GX'\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // 'K*'\r\n      if (phoneme === 72) {\r\n        // K <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>\r\n        // Example: COW\r\n        let Y = getPhoneme(pos + 1);\r\n        // If at end, replace current phoneme with KX\r\n        if (!phonemeHasFlag(Y, FLAG_DIP_YX) || Y === null) {\r\n          // VOWELS AND DIPHTHONGS ENDING WITH IY SOUND flag set?\r\n          {\r\n            console.log(`${pos} K <VOWEL OR DIPHTHONG NOT ENDING WITH IY> -> KX <VOWEL OR DIPHTHONG NOT ENDING WITH IY>`);\r\n          }\r\n          setPhoneme(pos, 75);\r\n          phoneme = 75;\r\n        }\r\n      }\r\n\r\n      // Replace with softer version?\r\n      if (phonemeHasFlag(phoneme, FLAG_UNVOICED_STOPCONS) && priorPhoneme === 32) {\r\n        // 'S*'\r\n        // RULE:\r\n        //   'S*' 'P*' -> 'S*' 'B*'\r\n        //   'S*' 'T*' -> 'S*' 'D*'\r\n        //   'S*' 'K*' -> 'S*' 'G*'\r\n        //   'S*' 'KX' -> 'S*' 'GX'\r\n        //   'S*' 'UM' -> 'S*' '**'\r\n        //   'S*' 'UN' -> 'S*' '**'\r\n        // Examples: SPY, STY, SKY, SCOWL\r\n        {\r\n          console.log(`${pos} RULE: S* ${PhonemeNameTable[phoneme]} -> S* ${PhonemeNameTable[phoneme - 12]}`);\r\n        }\r\n        setPhoneme(pos, phoneme - 12);\r\n      } else if (!phonemeHasFlag(phoneme, FLAG_UNVOICED_STOPCONS)) {\r\n        handleUW_CH_J(phoneme, pos);\r\n      }\r\n\r\n      // 'T*', 'D*'\r\n      if (phoneme === 69 || phoneme === 57) {\r\n        // RULE: Soften T following vowel\r\n        // NOTE: This rule fails for cases such as \"ODD\"\r\n        //       <UNSTRESSED VOWEL> T <PAUSE> -> <UNSTRESSED VOWEL> DX <PAUSE>\r\n        //       <UNSTRESSED VOWEL> D <PAUSE>  -> <UNSTRESSED VOWEL> DX <PAUSE>\r\n        // Example: PARTY, TARDY\r\n        if (pos > 0 && phonemeHasFlag(getPhoneme(pos - 1), FLAG_VOWEL)) {\r\n          phoneme = getPhoneme(pos + 1);\r\n          if (phoneme === 0) {\r\n            phoneme = getPhoneme(pos + 2);\r\n          }\r\n          if (phonemeHasFlag(phoneme, FLAG_VOWEL) && !getStress(pos + 1)) {\r\n            {\r\n              console.log(`${pos} Soften T or D following vowel or ER and preceding a pause -> DX`);\r\n            }\r\n            setPhoneme(pos, 30);\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n      {\r\n        console.log(`${pos}: ${PhonemeNameTable[phoneme]}`);\r\n      }\r\n    } // while\r\n  };\r\n\r\n  /**\r\n   * Applies various rules that adjust the lengths of phonemes\r\n   *\r\n   * Lengthen <!FRICATIVE> or <VOICED> between <VOWEL> and <PUNCTUATION> by 1.5\r\n   * <VOWEL> <RX | LX> <CONSONANT> - decrease <VOWEL> length by 1\r\n   * <VOWEL> <UNVOICED PLOSIVE> - decrease vowel by 1/8th\r\n   * <VOWEL> <VOICED CONSONANT> - increase vowel by 1/4 + 1\r\n   * <NASAL> <STOP CONSONANT> - set nasal = 5, consonant = 6\r\n   * <STOP CONSONANT> {optional silence} <STOP CONSONANT> - shorten both to 1/2 + 1\r\n   * <STOP CONSONANT> <LIQUID> - decrease <LIQUID> by 2\r\n   *\r\n   * @param {getPhoneme}    getPhoneme Callback for retrieving phonemes.\r\n   * @param {setPhonemeLength} setLength  Callback for setting phoneme length.\r\n   * @param {getPhonemeLength} getLength  Callback for retrieving phoneme length.\r\n   *\r\n   * @return undefined\r\n   */\r\n  let AdjustLengths = (getPhoneme, setLength, getLength) => {\r\n    {\r\n      console.log(`AdjustLengths()`);\r\n    }\r\n\r\n    // LENGTHEN VOWELS PRECEDING PUNCTUATION\r\n    //\r\n    // Search for punctuation. If found, back up to the first vowel, then\r\n    // process all phonemes between there and up to (but not including) the punctuation.\r\n    // If any phoneme is found that is a either a fricative or voiced, the duration is\r\n    // increased by (length * 1.5) + 1\r\n\r\n    // loop index\r\n    for (let position = 0; getPhoneme(position) !== null; position++) {\r\n      // not punctuation?\r\n      if (!phonemeHasFlag(getPhoneme(position), FLAG_PUNCT)) {\r\n        continue;\r\n      }\r\n      let loopIndex = position;\r\n      while (--position > 1 && !phonemeHasFlag(getPhoneme(position), FLAG_VOWEL)) {/* back up while not a vowel */}\r\n      // If beginning of phonemes, exit loop.\r\n      if (position === 0) {\r\n        break;\r\n      }\r\n\r\n      // Now handle everything between position and loopIndex\r\n      let vowel = position;\r\n      for (; position < loopIndex; position++) {\r\n        // test for not fricative/unvoiced or not voiced\r\n        if (!phonemeHasFlag(getPhoneme(position), FLAG_FRICATIVE) || phonemeHasFlag(getPhoneme(position), FLAG_VOICED)) {\r\n          let A = getLength(position);\r\n          // change phoneme length to (length * 1.5) + 1\r\n          {\r\n            console.log(position + ' RULE: Lengthen <!FRICATIVE> or <VOICED> ' + PhonemeNameTable[getPhoneme(position)] + ' between VOWEL:' + PhonemeNameTable[getPhoneme(vowel)] + ' and PUNCTUATION:' + PhonemeNameTable[getPhoneme(position)] + ' by 1.5');\r\n          }\r\n          setLength(position, (A >> 1) + A + 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Similar to the above routine, but shorten vowels under some circumstances\r\n    // Loop through all phonemes\r\n    let loopIndex = -1;\r\n    let phoneme;\r\n    while ((phoneme = getPhoneme(++loopIndex)) !== null) {\r\n      let position = loopIndex;\r\n      // vowel?\r\n      if (phonemeHasFlag(phoneme, FLAG_VOWEL)) {\r\n        // get next phoneme\r\n        phoneme = getPhoneme(++position);\r\n        // not a consonant\r\n        if (!phonemeHasFlag(phoneme, FLAG_CONSONANT)) {\r\n          // 'RX' or 'LX'?\r\n          if ((phoneme === 18 || phoneme === 19) && phonemeHasFlag(getPhoneme(++position), FLAG_CONSONANT)) {\r\n            // followed by consonant?\r\n            {\r\n              console.log(loopIndex + ' RULE: <VOWEL ' + PhonemeNameTable[getPhoneme(loopIndex)] + '>' + PhonemeNameTable[phoneme] + ' <CONSONANT: ' + PhonemeNameTable[getPhoneme(position)] + '> - decrease length of vowel by 1');\r\n            }\r\n            // decrease length of vowel by 1 frame\r\n            setLength(loopIndex, getLength(loopIndex) - 1);\r\n          }\r\n          continue;\r\n        }\r\n        // Got here if not <VOWEL>\r\n        // FIXME: the case when phoneme === END is taken over by !phonemeHasFlag(phoneme, FLAG_CONSONANT)\r\n        let flags = phoneme === null ? FLAG_CONSONANT | FLAG_UNVOICED_STOPCONS : phonemeFlags[phoneme];\r\n        // Unvoiced\r\n        if (!matchesBitmask(flags, FLAG_VOICED)) {\r\n          // *, .*, ?*, ,*, -*, DX, S*, SH, F*, TH, /H, /X, CH, P*, T*, K*, KX\r\n\r\n          // unvoiced plosive\r\n          if (matchesBitmask(flags, FLAG_UNVOICED_STOPCONS)) {\r\n            // RULE: <VOWEL> <UNVOICED PLOSIVE>\r\n            // <VOWEL> <P*, T*, K*, KX>\r\n            {\r\n              console.log(`${loopIndex} <VOWEL> <UNVOICED PLOSIVE> - decrease vowel by 1/8th`);\r\n            }\r\n            let A = getLength(loopIndex);\r\n            setLength(loopIndex, A - (A >> 3));\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // RULE: <VOWEL> <VOWEL or VOICED CONSONANT>\r\n        // <VOWEL> <IY, IH, EH, AE, AA, AH, AO, UH, AX, IX, ER, UX, OH, RX, LX, WX, YX, WH, R*, L*, W*,\r\n        //          Y*, M*, N*, NX, Q*, Z*, ZH, V*, DH, J*, EY, AY, OY, AW, OW, UW, B*, D*, G*, GX>\r\n        {\r\n          console.log(`${loopIndex} RULE: <VOWEL> <VOWEL or VOICED CONSONANT> - increase vowel by 1/4 + 1`);\r\n        }\r\n        // increase length\r\n        let A = getLength(loopIndex);\r\n        setLength(loopIndex, (A >> 2) + A + 1); // 5/4*A + 1\r\n        continue;\r\n      }\r\n\r\n      //  *, .*, ?*, ,*, -*, WH, R*, L*, W*, Y*, M*, N*, NX, DX, Q*, S*, SH, F*,\r\n      // TH, /H, /X, Z*, ZH, V*, DH, CH, J*, B*, D*, G*, GX, P*, T*, K*, KX\r\n\r\n      // nasal?\r\n      if (phonemeHasFlag(phoneme, FLAG_NASAL)) {\r\n        // RULE: <NASAL> <STOP CONSONANT>\r\n        //       Set punctuation length to 6\r\n        //       Set stop consonant length to 5\r\n\r\n        // M*, N*, NX,\r\n        phoneme = getPhoneme(++position);\r\n        // is next phoneme a stop consonant?\r\n        if (phoneme !== null && phonemeHasFlag(phoneme, FLAG_STOPCONS)) {\r\n          // B*, D*, G*, GX, P*, T*, K*, KX\r\n          {\r\n            console.log(`${position} RULE: <NASAL> <STOP CONSONANT> - set nasal = 5, consonant = 6`);\r\n          }\r\n          setLength(position, 6); // set stop consonant length to 6\r\n          setLength(position - 1, 5); // set nasal length to 5\r\n        }\r\n        continue;\r\n      }\r\n\r\n      //  *, .*, ?*, ,*, -*, WH, R*, L*, W*, Y*, DX, Q*, S*, SH, F*, TH,\r\n      // /H, /X, Z*, ZH, V*, DH, CH, J*, B*, D*, G*, GX, P*, T*, K*, KX\r\n\r\n      // stop consonant?\r\n      if (phonemeHasFlag(phoneme, FLAG_STOPCONS)) {\r\n        // B*, D*, G*, GX\r\n\r\n        // RULE: <STOP CONSONANT> {optional silence} <STOP CONSONANT>\r\n        //       Shorten both to (length/2 + 1)\r\n\r\n        while ((phoneme = getPhoneme(++position)) === 0) {/* move past silence */}\r\n        // if another stop consonant, process.\r\n        if (phoneme !== null && phonemeHasFlag(phoneme, FLAG_STOPCONS)) {\r\n          // RULE: <STOP CONSONANT> {optional silence} <STOP CONSONANT>\r\n          {\r\n            console.log(`${position} RULE: <STOP CONSONANT> {optional silence} <STOP CONSONANT> - shorten both to 1/2 + 1`);\r\n          }\r\n          setLength(position, (getLength(position) >> 1) + 1);\r\n          setLength(loopIndex, (getLength(loopIndex) >> 1) + 1);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      //  *, .*, ?*, ,*, -*, WH, R*, L*, W*, Y*, DX, Q*, S*, SH, F*, TH,\r\n      // /H, /X, Z*, ZH, V*, DH, CH, J*\r\n\r\n      // liquic consonant?\r\n      if (position > 0 && phonemeHasFlag(phoneme, FLAG_LIQUIC) && phonemeHasFlag(getPhoneme(position - 1), FLAG_STOPCONS)) {\r\n        // R*, L*, W*, Y*\r\n        // RULE: <STOP CONSONANT> <LIQUID>\r\n        //       Decrease <LIQUID> by 2\r\n        // prior phoneme is a stop consonant\r\n        {\r\n          console.log(`${position} RULE: <STOP CONSONANT> <LIQUID> - decrease by 2`);\r\n        }\r\n        // decrease the phoneme length by 2 frames\r\n        setLength(position, getLength(position) - 2);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Iterates through the phoneme buffer, copying the stress value from\r\n   * the following phoneme under the following circumstance:\r\n   *     1. The current phoneme is voiced, excluding plosives and fricatives\r\n   *     2. The following phoneme is voiced, excluding plosives and fricatives, and\r\n   *     3. The following phoneme is stressed\r\n   *\r\n   *  In those cases, the stress value+1 from the following phoneme is copied.\r\n   *\r\n   * For example, the word LOITER is represented as LOY5TER, with as stress\r\n   * of 5 on the diphthong OY. This routine will copy the stress value of 6 (5+1)\r\n   * to the L that precedes it.\r\n   *\r\n   * @param {getPhoneme}       getPhoneme Callback for retrieving phonemes.\r\n   * @param {getPhonemeStress} getStress  Callback for retrieving phoneme stress.\r\n   * @param {setPhonemeStress} setStress  Callback for setting phoneme stress.\r\n   *\r\n   * @return undefined\r\n   */\r\n  let CopyStress = (getPhoneme, getStress, setStress) => {\r\n    // loop through all the phonemes to be output\r\n    let position = 0;\r\n    let phoneme;\r\n    while ((phoneme = getPhoneme(position)) !== null) {\r\n      // if CONSONANT_FLAG set, skip - only vowels get stress\r\n      if (phonemeHasFlag(phoneme, FLAG_CONSONANT)) {\r\n        phoneme = getPhoneme(position + 1);\r\n        // if the following phoneme is the end, or a vowel, skip\r\n        if (phoneme !== null && phonemeHasFlag(phoneme, FLAG_VOWEL)) {\r\n          // get the stress value at the next position\r\n          let stress = getStress(position + 1);\r\n          if (stress !== 0 && stress < 0x80) {\r\n            // if next phoneme is stressed, and a VOWEL OR ER\r\n            // copy stress from next phoneme to this one\r\n            setStress(position, stress + 1);\r\n          }\r\n        }\r\n      }\r\n      ++position;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * change phoneme length dependent on stress\r\n   *\r\n   * @param {getPhoneme}    getPhoneme Callback for retrieving phonemes.\r\n   * @param {getPhonemeStress} getStress  Callback for retrieving phoneme length.\r\n   * @param {setPhonemeLength} setLength  Callback for setting phoneme length.\r\n   *\r\n   * @return undefined\r\n   */\r\n  let SetPhonemeLength = (getPhoneme, getStress, setLength) => {\r\n    let position = 0;\r\n    let phoneme;\r\n    while ((phoneme = getPhoneme(position)) !== null) {\r\n      let stress = getStress(position);\r\n      if (stress === 0 || stress > 0x7F) {\r\n        setLength(position, combinedPhonemeLengthTable[phoneme] & 0xFF);\r\n      } else {\r\n        setLength(position, combinedPhonemeLengthTable[phoneme] >> 8);\r\n      }\r\n      position++;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Makes plosive stop consonants longer by inserting the next two following\r\n   * phonemes from the table right behind the consonant.\r\n   *\r\n   * @param {getPhoneme}       getPhoneme Callback for retrieving phonemes.\r\n   * @param {insertPhoneme}    insertPhoneme Callback for inserting phonemes.\r\n   * @param {getPhonemeStress} getStress Callback for retrieving stress.\r\n   *\r\n   * @return undefined\r\n   */\r\n  let ProlongPlosiveStopConsonantsCode41240 = (getPhoneme, insertPhoneme, getStress) => {\r\n    let pos = -1;\r\n    let index;\r\n    while ((index = getPhoneme(++pos)) !== null) {\r\n      // Not a stop consonant, move to next one.\r\n      if (!phonemeHasFlag(index, FLAG_STOPCONS)) {\r\n        continue;\r\n      }\r\n      //If plosive, move to next non empty phoneme and validate the flags.\r\n      if (phonemeHasFlag(index, FLAG_UNVOICED_STOPCONS)) {\r\n        let nextNonEmpty;\r\n        let X = pos;\r\n        do {\r\n          nextNonEmpty = getPhoneme(++X);\r\n        } while (nextNonEmpty === 0);\r\n        // If not END and either flag 0x0008 or '/H' or '/X'\r\n        if (nextNonEmpty !== null && (phonemeHasFlag(nextNonEmpty, FLAG_0008) || nextNonEmpty === 36 || nextNonEmpty === 37)) {\r\n          continue;\r\n        }\r\n      }\r\n      insertPhoneme(pos + 1, index + 1, getStress(pos), combinedPhonemeLengthTable[index + 1] & 0xFF);\r\n      insertPhoneme(pos + 2, index + 2, getStress(pos), combinedPhonemeLengthTable[index + 2] & 0xFF);\r\n      pos += 2;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Parses speech data.\r\n   *\r\n   * Returns array of [phoneme, length, stress]\r\n   *\r\n   * @param {string} input\r\n   *\r\n   * @return {Array|Boolean} The parsed data.\r\n   */\r\n  let Parser = input => {\r\n    if (!input) {\r\n      return false;\r\n    }\r\n    let getPhoneme = pos => {\r\n      {\r\n        if (pos < 0 || pos > phonemeindex.length) {\r\n          throw new Error('Out of bounds: ' + pos);\r\n        }\r\n      }\r\n      return pos === phonemeindex.length ? null : phonemeindex[pos];\r\n    };\r\n    let setPhoneme = (pos, value) => {\r\n      {\r\n        console.log(`${pos} CHANGE: ${PhonemeNameTable[phonemeindex[pos]]} -> ${PhonemeNameTable[value]}`);\r\n      }\r\n      phonemeindex[pos] = value;\r\n    };\r\n\r\n    /**\r\n     * @param {Number} pos         The position in the phoneme array to insert at.\r\n     * @param {Number} value       The phoneme to insert.\r\n     * @param {Number} stressValue The stress.\r\n     * @param {Number} [length]    The (optional) phoneme length, if not given, length will be 0.\r\n     *\r\n     * @return {undefined}\r\n     */\r\n    let insertPhoneme = (pos, value, stressValue, length) => {\r\n      {\r\n        console.log(`${pos} INSERT: ${PhonemeNameTable[value]}`);\r\n      }\r\n      for (let i = phonemeindex.length - 1; i >= pos; i--) {\r\n        phonemeindex[i + 1] = phonemeindex[i];\r\n        phonemeLength[i + 1] = getLength(i);\r\n        stress[i + 1] = getStress(i);\r\n      }\r\n      phonemeindex[pos] = value;\r\n      phonemeLength[pos] = length | 0;\r\n      stress[pos] = stressValue;\r\n    };\r\n    let getStress = pos => stress[pos] | 0;\r\n    let setStress = (pos, stressValue) => {\r\n      {\r\n        console.log(`${pos} \"${PhonemeNameTable[phonemeindex[pos]]}\" SET STRESS: ${stress[pos]} -> ${stressValue}`);\r\n      }\r\n      stress[pos] = stressValue;\r\n    };\r\n    let getLength = pos => phonemeLength[pos] | 0;\r\n    let setLength = (pos, length) => {\r\n      {\r\n        console.log(`${pos} \"${PhonemeNameTable[phonemeindex[pos]]}\" SET LENGTH: ${phonemeLength[pos]} -> ${length}`);\r\n        if ((length & 128) !== 0) {\r\n          throw new Error('Got the flag 0x80, see CopyStress() and SetPhonemeLength() comments!');\r\n        }\r\n        if (pos < 0 || pos > phonemeindex.length) {\r\n          throw new Error('Out of bounds: ' + pos);\r\n        }\r\n      }\r\n      phonemeLength[pos] = length;\r\n    };\r\n    let stress = []; //numbers from 0 to 8\r\n    let phonemeLength = [];\r\n    let phonemeindex = [];\r\n    let pos = 0;\r\n    Parser1(input, value => {\r\n      stress[pos] = 0;\r\n      phonemeLength[pos] = 0;\r\n      phonemeindex[pos++] = value;\r\n    }, value => {\r\n      {\r\n        if ((value & 128) !== 0) {\r\n          throw new Error('Got the flag 0x80, see CopyStress() and SetPhonemeLength() comments!');\r\n        }\r\n      }\r\n      stress[pos - 1] = value; /* Set stress for prior phoneme */\r\n    });\r\n    {\r\n      PrintPhonemes(phonemeindex, phonemeLength, stress);\r\n    }\r\n    Parser2(insertPhoneme, setPhoneme, getPhoneme, getStress);\r\n    CopyStress(getPhoneme, getStress, setStress);\r\n    SetPhonemeLength(getPhoneme, getStress, setLength);\r\n    AdjustLengths(getPhoneme, setLength, getLength);\r\n    ProlongPlosiveStopConsonantsCode41240(getPhoneme, insertPhoneme, getStress);\r\n    {\r\n      PrintPhonemes(phonemeindex, phonemeLength, stress);\r\n    }\r\n    return phonemeindex.map((v, i) => v ? [v, phonemeLength[i] | 0, stress[i] | 0] : null).filter(v => v);\r\n  };\r\n\r\n  /**\r\n   * Debug printing.\r\n   *\r\n   * @param {Array} phonemeindex\r\n   * @param {Array} phonemeLength\r\n   * @param {Array} stress\r\n   *\r\n   * @return undefined\r\n   */\r\n  let PrintPhonemes = (phonemeindex, phonemeLength, stress) => {\r\n    let pad = num => {\r\n      let s = '000' + num;\r\n      return s.substr(s.length - 3);\r\n    };\r\n    console.log('==================================');\r\n    console.log('Internal Phoneme presentation:');\r\n    console.log(' pos  idx  phoneme  length  stress');\r\n    console.log('----------------------------------');\r\n    for (let i = 0; i < phonemeindex.length; i++) {\r\n      let name = () => {\r\n        if (phonemeindex[i] < 81) {\r\n          return PhonemeNameTable[phonemeindex[i]];\r\n        }\r\n        return '??';\r\n      };\r\n      console.log(' %s  %s  %s       %s     %s', pad(i), pad(phonemeindex[i]), name(phonemeindex[i]), pad(phonemeLength[i]), pad(stress[i]));\r\n    }\r\n    console.log('==================================');\r\n  };\r\n\r\n  // Values substituted for zero bits in unvoiced consonant samples.\r\n  // tab48426\r\n  let sampledConsonantValues0 = [0x18, 0x1A, 0x17, 0x17, 0x17];\r\n  let stressPitch_tab47492 = [0x00, 0xE0, 0xE6, 0xEC, 0xF3, 0xF9, 0x00, 0x06, 0xC, 0x06];\r\n\r\n  // Used to decide which phoneme's blend lengths. The candidate with the lower score is selected.\r\n  // tab45856\r\n  let blendRank = [0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0x02, 0x0A, 0x02, 0x08, 0x05, 0x05, 0x0B, 0x0A, 0x09, 0x08, 0x08, 0xA0, 0x08, 0x08, 0x17, 0x1F, 0x12, 0x12, 0x12, 0x12, 0x1E, 0x1E, 0x14, 0x14, 0x14, 0x14, 0x17, 0x17, 0x1A, 0x1A, 0x1D, 0x1D, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1A, 0x1D, 0x1B, 0x1A, 0x1D, 0x1B, 0x1A, 0x1D, 0x1B, 0x1A, 0x1D, 0x1B, 0x17, 0x1D, 0x17, 0x17, 0x1D, 0x17, 0x17, 0x1D, 0x17, 0x17, 0x1D, 0x17, 0x17, 0x17];\r\n\r\n  // Number of frames at the end of a phoneme devoted to interpolating to next phoneme's final value\r\n  //tab45696\r\n  let outBlendLength = [0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x02, 0x00, 0x01, 0x02, 0x00, 0x01, 0x02, 0x00, 0x01, 0x02, 0x00, 0x02, 0x02, 0x00, 0x01, 0x03, 0x00, 0x02, 0x03, 0x00, 0x02, 0xA0, 0xA0];\r\n\r\n  // Number of frames at beginning of a phoneme devoted to interpolating to phoneme's final value\r\n  // tab45776\r\n  let inBlendLength = [0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x02, 0x03, 0x02, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x03, 0x02, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x04, 0x02, 0x00, 0x03, 0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x03, 0x00, 0x03, 0x03, 0x00, 0x03, 0xB0, 0xA0];\r\n\r\n  // Consists of two bitfields:\r\n  // Low 3 bits (masked by 7) select a 256-byte section in sampleTable,\r\n  // as well as index into sampledConsonantValues0 for unvoiced.\r\n  // High 5 bits (masked by 248 = 11111000), for unvoiced,\r\n  // give inverted offset within the 256-byte section.\r\n  //\r\n  // 32: S*    241         11110001\r\n  // 33: SH    226         11100010\r\n  // 34: F*    211         11010011\r\n  // 35: TH    187         10111011\r\n  // 36: /H    124         01111100\r\n  // 37: /X    149         10010101\r\n  // 38: Z*    1           00000001\r\n  // 39: ZH    2           00000010\r\n  // 40: V*    3           00000011\r\n  // 41: DH    3           00000011\r\n  // 43: CH'   114         01110010\r\n  // 45: J'    2           00000010\r\n  // 67: P'    27          00011011\r\n  // 70: T'    25          00011001\r\n  // tab45936\r\n  let sampledConsonantFlags = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0xD3, 0xBB, 0x7C, 0x95, 0x01, 0x02, 0x03, 0x03, 0x00, 0x72, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\r\n\r\n  //\r\n  let frequencyData = [\r\n  //tab45056 |tab451356 |tab45216\r\n  //  freq1  |  freq2   |  freq3\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // ' *' 00\r\n  0x000013 | 0x004300 | 0x5B0000,\r\n  // '.*' 01\r\n  0x000013 | 0x004300 | 0x5B0000,\r\n  // '?*' 02\r\n  0x000013 | 0x004300 | 0x5B0000,\r\n  // ',*' 03\r\n  0x000013 | 0x004300 | 0x5B0000,\r\n  // '-*' 04\r\n  0x00000A | 0x005400 | 0x6E0000,\r\n  // 'IY' 05\r\n  0x00000E | 0x004900 | 0x5D0000,\r\n  // 'IH' 06\r\n  0x000013 | 0x004300 | 0x5B0000,\r\n  // 'EH' 07\r\n  0x000018 | 0x003F00 | 0x580000,\r\n  // 'AE' 08\r\n  0x00001B | 0x002800 | 0x590000,\r\n  // 'AA' 09\r\n  0x000017 | 0x002C00 | 0x570000,\r\n  // 'AH' 10\r\n  0x000015 | 0x001F00 | 0x580000,\r\n  // 'AO' 11\r\n  0x000010 | 0x002500 | 0x520000,\r\n  // 'UH' 12\r\n  0x000014 | 0x002D00 | 0x590000,\r\n  // 'AX' 13\r\n  0x00000E | 0x004900 | 0x5D0000,\r\n  // 'IX' 14\r\n  0x000012 | 0x003100 | 0x3E0000,\r\n  // 'ER' 15\r\n  0x00000E | 0x002400 | 0x520000,\r\n  // 'UX' 16\r\n  0x000012 | 0x001E00 | 0x580000,\r\n  // 'OH' 17\r\n  0x000012 | 0x003300 | 0x3E0000,\r\n  // 'RX' 18\r\n  0x000010 | 0x002500 | 0x6E0000,\r\n  // 'LX' 19\r\n  0x00000D | 0x001D00 | 0x500000,\r\n  // 'WX' 20\r\n  0x00000F | 0x004500 | 0x5D0000,\r\n  // 'YX' 21\r\n  0x00000B | 0x001800 | 0x5A0000,\r\n  // 'WH' 22\r\n  0x000012 | 0x003200 | 0x3C0000,\r\n  // 'R*' 23\r\n  0x00000E | 0x001E00 | 0x6E0000,\r\n  // 'L*' 24\r\n  0x00000B | 0x001800 | 0x5A0000,\r\n  // 'W*' 25\r\n  0x000009 | 0x005300 | 0x6E0000,\r\n  // 'Y*' 26\r\n  0x000006 | 0x002E00 | 0x510000,\r\n  // 'M*' 27\r\n  0x000006 | 0x003600 | 0x790000,\r\n  // 'N*' 28\r\n  0x000006 | 0x005600 | 0x650000,\r\n  // 'NX' 29\r\n  0x000006 | 0x003600 | 0x790000,\r\n  // 'DX' 30\r\n  0x000011 | 0x004300 | 0x5B0000,\r\n  // 'Q*' 31\r\n  0x000006 | 0x004900 | 0x630000,\r\n  // 'S*' 32\r\n  0x000006 | 0x004F00 | 0x6A0000,\r\n  // 'SH' 33\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // 'F*' 34\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // 'TH' 35\r\n  0x00000E | 0x004900 | 0x5D0000,\r\n  // '/H' 36\r\n  0x000010 | 0x002500 | 0x520000,\r\n  // '/X' 37\r\n  0x000009 | 0x003300 | 0x5D0000,\r\n  // 'Z*' 38\r\n  0x00000A | 0x004200 | 0x670000,\r\n  // 'ZH' 39\r\n  0x000008 | 0x002800 | 0x4C0000,\r\n  // 'V*' 40\r\n  0x00000A | 0x002F00 | 0x5D0000,\r\n  // 'DH' 41\r\n  0x000006 | 0x004F00 | 0x650000,\r\n  // 'CH' 42\r\n  0x000006 | 0x004F00 | 0x650000,\r\n  // '**' 43\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // 'J*' 44\r\n  0x000005 | 0x004F00 | 0x650000,\r\n  // '**' 45\r\n  0x000006 | 0x006E00 | 0x790000,\r\n  // '**' 46\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 47\r\n  0x000013 | 0x004800 | 0x5A0000,\r\n  // 'EY' 48\r\n  0x00001B | 0x002700 | 0x580000,\r\n  // 'AY' 49\r\n  0x000015 | 0x001F00 | 0x580000,\r\n  // 'OY' 50\r\n  0x00001B | 0x002B00 | 0x580000,\r\n  // 'AW' 51\r\n  0x000012 | 0x001E00 | 0x580000,\r\n  // 'OW' 52\r\n  0x00000D | 0x002200 | 0x520000,\r\n  // 'UW' 53\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // 'B*' 54\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // '**' 55\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // '**' 56\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // 'D*' 57\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // '**' 58\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // '**' 59\r\n  0x000006 | 0x006E00 | 0x700000,\r\n  // 'G*' 60\r\n  0x000006 | 0x006E00 | 0x6E0000,\r\n  // '**' 61\r\n  0x000006 | 0x006E00 | 0x6E0000,\r\n  // '**' 62\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // 'GX' 63\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // '**' 64\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // '**' 65\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // 'P*' 66\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // '**' 67\r\n  0x000006 | 0x001A00 | 0x510000,\r\n  // '**' 68\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // 'T*' 69\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // '**' 70\r\n  0x000006 | 0x004200 | 0x790000,\r\n  // '**' 71\r\n  0x000006 | 0x006D00 | 0x650000,\r\n  // 'K*' 72\r\n  0x00000A | 0x005600 | 0x650000,\r\n  // '**' 73\r\n  0x00000A | 0x006D00 | 0x700000,\r\n  // '**' 74\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // 'KX' 75\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // '**' 76\r\n  0x000006 | 0x005400 | 0x5E0000,\r\n  // '**' 77\r\n  0x00002C | 0x007F00 | 0x080000,\r\n  // 'UL' 78\r\n  0x000013 | 0x007F00 | 0x010000 // 'UM' 79\r\n  ];\r\n\r\n  /**\r\n   *\r\n   * ampl1data[X] =  ampldata[X]        & 0xFF; // F1 amplitude\r\n   * ampl2data[X] = (ampldata[X] >> 8)  & 0xFF; // F2 amplitude\r\n   * ampl3data[X] = (ampldata[X] >> 16) & 0xFF; // F3 amplitude\r\n   */\r\n  let ampldata = [\r\n  // ampl1   | ampl2    | ampl3\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // ' *' 00\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '.*' 01\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '?*' 02\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // ',*' 03\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '-*' 04\r\n  0x00000D | 0x000A00 | 0x080000,\r\n  // 'IY' 05\r\n  0x00000D | 0x000B00 | 0x070000,\r\n  // 'IH' 06\r\n  0x00000E | 0x000D00 | 0x080000,\r\n  // 'EH' 07\r\n  0x00000F | 0x000E00 | 0x080000,\r\n  // 'AE' 08\r\n  0x00000F | 0x000D00 | 0x010000,\r\n  // 'AA' 09\r\n  0x00000F | 0x000C00 | 0x010000,\r\n  // 'AH' 10\r\n  0x00000F | 0x000C00 | 0x000000,\r\n  // 'AO' 11\r\n  0x00000F | 0x000B00 | 0x010000,\r\n  // 'UH' 12\r\n  0x00000C | 0x000900 | 0x000000,\r\n  // 'AX' 13\r\n  0x00000D | 0x000B00 | 0x070000,\r\n  // 'IX' 14\r\n  0x00000C | 0x000B00 | 0x050000,\r\n  // 'ER' 15\r\n  0x00000F | 0x000C00 | 0x010000,\r\n  // 'UX' 16\r\n  0x00000F | 0x000C00 | 0x000000,\r\n  // 'OH' 17\r\n  0x00000D | 0x000C00 | 0x060000,\r\n  // 'RX' 18\r\n  0x00000D | 0x000800 | 0x010000,\r\n  // 'LX' 19\r\n  0x00000D | 0x000800 | 0x000000,\r\n  // 'WX' 20\r\n  0x00000E | 0x000C00 | 0x070000,\r\n  // 'YX' 21\r\n  0x00000D | 0x000800 | 0x000000,\r\n  // 'WH' 22\r\n  0x00000C | 0x000A00 | 0x050000,\r\n  // 'R*' 23\r\n  0x00000D | 0x000800 | 0x010000,\r\n  // 'L*' 24\r\n  0x00000D | 0x000800 | 0x000000,\r\n  // 'W*' 25\r\n  0x00000D | 0x000A00 | 0x080000,\r\n  // 'Y*' 26\r\n  0x00000C | 0x000300 | 0x000000,\r\n  // 'M*' 27\r\n  0x000009 | 0x000900 | 0x000000,\r\n  // 'N*' 28\r\n  0x000009 | 0x000600 | 0x030000,\r\n  // 'NX' 29\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'DX' 30\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'Q*' 31\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'S*' 32\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'SH' 33\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'F*' 34\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'TH' 35\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '/H' 36\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '/X' 37\r\n  0x00000B | 0x000300 | 0x000000,\r\n  // 'Z*' 38\r\n  0x00000B | 0x000500 | 0x010000,\r\n  // 'ZH' 39\r\n  0x00000B | 0x000300 | 0x000000,\r\n  // 'V*' 40\r\n  0x00000B | 0x000400 | 0x000000,\r\n  // 'DH' 41\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'CH' 42\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 43\r\n  0x000001 | 0x000000 | 0x000000,\r\n  // 'J*' 44\r\n  0x00000B | 0x000500 | 0x010000,\r\n  // '**' 45\r\n  0x000000 | 0x000A00 | 0x0E0000,\r\n  // '**' 46\r\n  0x000002 | 0x000200 | 0x010000,\r\n  // '**' 47\r\n  0x00000E | 0x000E00 | 0x090000,\r\n  // 'EY' 48\r\n  0x00000F | 0x000D00 | 0x010000,\r\n  // 'AY' 49\r\n  0x00000F | 0x000C00 | 0x000000,\r\n  // 'OY' 50\r\n  0x00000F | 0x000D00 | 0x010000,\r\n  // 'AW' 51\r\n  0x00000F | 0x000C00 | 0x000000,\r\n  // 'OW' 52\r\n  0x00000D | 0x000800 | 0x000000,\r\n  // 'UW' 53\r\n  0x000002 | 0x000000 | 0x000000,\r\n  // 'B*' 54\r\n  0x000004 | 0x000100 | 0x000000,\r\n  // '**' 55\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 56\r\n  0x000002 | 0x000000 | 0x000000,\r\n  // 'D*' 57\r\n  0x000004 | 0x000100 | 0x000000,\r\n  // '**' 58\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 59\r\n  0x000001 | 0x000000 | 0x000000,\r\n  // 'G*' 60\r\n  0x000004 | 0x000100 | 0x000000,\r\n  // '**' 61\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 62\r\n  0x000001 | 0x000000 | 0x000000,\r\n  // 'GX' 63\r\n  0x000004 | 0x000100 | 0x000000,\r\n  // '**' 64\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 65\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'P*' 66\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 67\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 68\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'T*' 69\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 70\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 71\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'K*' 72\r\n  0x00000C | 0x000A00 | 0x070000,\r\n  // '**' 73\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 74\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // 'KX' 75\r\n  0x000000 | 0x000A00 | 0x050000,\r\n  // '**' 76\r\n  0x000000 | 0x000000 | 0x000000,\r\n  // '**' 77\r\n  0x00000F | 0x000000 | 0x130000,\r\n  // 'UL' 78\r\n  0x00000F | 0x000000 | 0x100000 // 'UM' 79\r\n  ];\r\n\r\n  // Sampled data for consonants, consisting of five 256-byte sections\r\n  let sampleTable = [\r\n  //00  T', S, Z  (coronal)\r\n  0x38, 0x84, 0x6B, 0x19, 0xC6, 0x63, 0x18, 0x86, 0x73, 0x98, 0xC6, 0xB1, 0x1C, 0xCA, 0x31, 0x8C, 0xC7, 0x31, 0x88, 0xC2, 0x30, 0x98, 0x46, 0x31, 0x18, 0xC6, 0x35, 0x0C, 0xCA, 0x31, 0x0C, 0xC6,\r\n  //20\r\n  0x21, 0x10, 0x24, 0x69, 0x12, 0xC2, 0x31, 0x14, 0xC4, 0x71, 0x08, 0x4A, 0x22, 0x49, 0xAB, 0x6A, 0xA8, 0xAC, 0x49, 0x51, 0x32, 0xD5, 0x52, 0x88, 0x93, 0x6C, 0x94, 0x22, 0x15, 0x54, 0xD2, 0x25,\r\n  //40\r\n  0x96, 0xD4, 0x50, 0xA5, 0x46, 0x21, 0x08, 0x85, 0x6B, 0x18, 0xC4, 0x63, 0x10, 0xCE, 0x6B, 0x18, 0x8C, 0x71, 0x19, 0x8C, 0x63, 0x35, 0x0C, 0xC6, 0x33, 0x99, 0xCC, 0x6C, 0xB5, 0x4E, 0xA2, 0x99,\r\n  //60\r\n  0x46, 0x21, 0x28, 0x82, 0x95, 0x2E, 0xE3, 0x30, 0x9C, 0xC5, 0x30, 0x9C, 0xA2, 0xB1, 0x9C, 0x67, 0x31, 0x88, 0x66, 0x59, 0x2C, 0x53, 0x18, 0x84, 0x67, 0x50, 0xCA, 0xE3, 0x0A, 0xAC, 0xAB, 0x30,\r\n  //80\r\n  0xAC, 0x62, 0x30, 0x8C, 0x63, 0x10, 0x94, 0x62, 0xB1, 0x8C, 0x82, 0x28, 0x96, 0x33, 0x98, 0xD6, 0xB5, 0x4C, 0x62, 0x29, 0xA5, 0x4A, 0xB5, 0x9C, 0xC6, 0x31, 0x14, 0xD6, 0x38, 0x9C, 0x4B, 0xB4,\r\n  //A0\r\n  0x86, 0x65, 0x18, 0xAE, 0x67, 0x1C, 0xA6, 0x63, 0x19, 0x96, 0x23, 0x19, 0x84, 0x13, 0x08, 0xA6, 0x52, 0xAC, 0xCA, 0x22, 0x89, 0x6E, 0xAB, 0x19, 0x8C, 0x62, 0x34, 0xC4, 0x62, 0x19, 0x86, 0x63,\r\n  //C0\r\n  0x18, 0xC4, 0x23, 0x58, 0xD6, 0xA3, 0x50, 0x42, 0x54, 0x4A, 0xAD, 0x4A, 0x25, 0x11, 0x6B, 0x64, 0x89, 0x4A, 0x63, 0x39, 0x8A, 0x23, 0x31, 0x2A, 0xEA, 0xA2, 0xA9, 0x44, 0xC5, 0x12, 0xCD, 0x42,\r\n  //E0\r\n  0x34, 0x8C, 0x62, 0x18, 0x8C, 0x63, 0x11, 0x48, 0x66, 0x31, 0x9D, 0x44, 0x33, 0x1D, 0x46, 0x31, 0x9C, 0xC6, 0xB1, 0x0C, 0xCD, 0x32, 0x88, 0xC4, 0x73, 0x18, 0x86, 0x73, 0x08, 0xD6, 0x63, 0x58,\r\n  //100 CH', J', SH, ZH  (palato-alveolar)\r\n  0x07, 0x81, 0xE0, 0xF0, 0x3C, 0x07, 0x87, 0x90, 0x3C, 0x7C, 0x0F, 0xC7, 0xC0, 0xC0, 0xF0, 0x7C, 0x1E, 0x07, 0x80, 0x80, 0x00, 0x1C, 0x78, 0x70, 0xF1, 0xC7, 0x1F, 0xC0, 0x0C, 0xFE, 0x1C, 0x1F,\r\n  //120\r\n  0x1F, 0x0E, 0x0A, 0x7A, 0xC0, 0x71, 0xF2, 0x83, 0x8F, 0x03, 0x0F, 0x0F, 0x0C, 0x00, 0x79, 0xF8, 0x61, 0xE0, 0x43, 0x0F, 0x83, 0xE7, 0x18, 0xF9, 0xC1, 0x13, 0xDA, 0xE9, 0x63, 0x8F, 0x0F, 0x83,\r\n  //140\r\n  0x83, 0x87, 0xC3, 0x1F, 0x3C, 0x70, 0xF0, 0xE1, 0xE1, 0xE3, 0x87, 0xB8, 0x71, 0x0E, 0x20, 0xE3, 0x8D, 0x48, 0x78, 0x1C, 0x93, 0x87, 0x30, 0xE1, 0xC1, 0xC1, 0xE4, 0x78, 0x21, 0x83, 0x83, 0xC3,\r\n  //160\r\n  0x87, 0x06, 0x39, 0xE5, 0xC3, 0x87, 0x07, 0x0E, 0x1C, 0x1C, 0x70, 0xF4, 0x71, 0x9C, 0x60, 0x36, 0x32, 0xC3, 0x1E, 0x3C, 0xF3, 0x8F, 0x0E, 0x3C, 0x70, 0xE3, 0xC7, 0x8F, 0x0F, 0x0F, 0x0E, 0x3C,\r\n  //180\r\n  0x78, 0xF0, 0xE3, 0x87, 0x06, 0xF0, 0xE3, 0x07, 0xC1, 0x99, 0x87, 0x0F, 0x18, 0x78, 0x70, 0x70, 0xFC, 0xF3, 0x10, 0xB1, 0x8C, 0x8C, 0x31, 0x7C, 0x70, 0xE1, 0x86, 0x3C, 0x64, 0x6C, 0xB0, 0xE1,\r\n  //1A0\r\n  0xE3, 0x0F, 0x23, 0x8F, 0x0F, 0x1E, 0x3E, 0x38, 0x3C, 0x38, 0x7B, 0x8F, 0x07, 0x0E, 0x3C, 0xF4, 0x17, 0x1E, 0x3C, 0x78, 0xF2, 0x9E, 0x72, 0x49, 0xE3, 0x25, 0x36, 0x38, 0x58, 0x39, 0xE2, 0xDE,\r\n  //1C0\r\n  0x3C, 0x78, 0x78, 0xE1, 0xC7, 0x61, 0xE1, 0xE1, 0xB0, 0xF0, 0xF0, 0xC3, 0xC7, 0x0E, 0x38, 0xC0, 0xF0, 0xCE, 0x73, 0x73, 0x18, 0x34, 0xB0, 0xE1, 0xC7, 0x8E, 0x1C, 0x3C, 0xF8, 0x38, 0xF0, 0xE1,\r\n  //1E0\r\n  0xC1, 0x8B, 0x86, 0x8F, 0x1C, 0x78, 0x70, 0xF0, 0x78, 0xAC, 0xB1, 0x8F, 0x39, 0x31, 0xDB, 0x38, 0x61, 0xC3, 0x0E, 0x0E, 0x38, 0x78, 0x73, 0x17, 0x1E, 0x39, 0x1E, 0x38, 0x64, 0xE1, 0xF1, 0xC1,\r\n  //200 P', F, V, TH, DH  ([labio]dental)\r\n  0x4E, 0x0F, 0x40, 0xA2, 0x02, 0xC5, 0x8F, 0x81, 0xA1, 0xFC, 0x12, 0x08, 0x64, 0xE0, 0x3C, 0x22, 0xE0, 0x45, 0x07, 0x8E, 0x0C, 0x32, 0x90, 0xF0, 0x1F, 0x20, 0x49, 0xE0, 0xF8, 0x0C, 0x60, 0xF0,\r\n  //220\r\n  0x17, 0x1A, 0x41, 0xAA, 0xA4, 0xD0, 0x8D, 0x12, 0x82, 0x1E, 0x1E, 0x03, 0xF8, 0x3E, 0x03, 0x0C, 0x73, 0x80, 0x70, 0x44, 0x26, 0x03, 0x24, 0xE1, 0x3E, 0x04, 0x4E, 0x04, 0x1C, 0xC1, 0x09, 0xCC,\r\n  //240\r\n  0x9E, 0x90, 0x21, 0x07, 0x90, 0x43, 0x64, 0xC0, 0x0F, 0xC6, 0x90, 0x9C, 0xC1, 0x5B, 0x03, 0xE2, 0x1D, 0x81, 0xE0, 0x5E, 0x1D, 0x03, 0x84, 0xB8, 0x2C, 0x0F, 0x80, 0xB1, 0x83, 0xE0, 0x30, 0x41,\r\n  //260\r\n  0x1E, 0x43, 0x89, 0x83, 0x50, 0xFC, 0x24, 0x2E, 0x13, 0x83, 0xF1, 0x7C, 0x4C, 0x2C, 0xC9, 0x0D, 0x83, 0xB0, 0xB5, 0x82, 0xE4, 0xE8, 0x06, 0x9C, 0x07, 0xA0, 0x99, 0x1D, 0x07, 0x3E, 0x82, 0x8F,\r\n  //280\r\n  0x70, 0x30, 0x74, 0x40, 0xCA, 0x10, 0xE4, 0xE8, 0x0F, 0x92, 0x14, 0x3F, 0x06, 0xF8, 0x84, 0x88, 0x43, 0x81, 0x0A, 0x34, 0x39, 0x41, 0xC6, 0xE3, 0x1C, 0x47, 0x03, 0xB0, 0xB8, 0x13, 0x0A, 0xC2,\r\n  //2A0\r\n  0x64, 0xF8, 0x18, 0xF9, 0x60, 0xB3, 0xC0, 0x65, 0x20, 0x60, 0xA6, 0x8C, 0xC3, 0x81, 0x20, 0x30, 0x26, 0x1E, 0x1C, 0x38, 0xD3, 0x01, 0xB0, 0x26, 0x40, 0xF4, 0x0B, 0xC3, 0x42, 0x1F, 0x85, 0x32,\r\n  //2C0\r\n  0x26, 0x60, 0x40, 0xC9, 0xCB, 0x01, 0xEC, 0x11, 0x28, 0x40, 0xFA, 0x04, 0x34, 0xE0, 0x70, 0x4C, 0x8C, 0x1D, 0x07, 0x69, 0x03, 0x16, 0xC8, 0x04, 0x23, 0xE8, 0xC6, 0x9A, 0x0B, 0x1A, 0x03, 0xE0,\r\n  //2E0\r\n  0x76, 0x06, 0x05, 0xCF, 0x1E, 0xBC, 0x58, 0x31, 0x71, 0x66, 0x00, 0xF8, 0x3F, 0x04, 0xFC, 0x0C, 0x74, 0x27, 0x8A, 0x80, 0x71, 0xC2, 0x3A, 0x26, 0x06, 0xC0, 0x1F, 0x05, 0x0F, 0x98, 0x40, 0xAE,\r\n  //300 /H  (palatal)\r\n  0x01, 0x7F, 0xC0, 0x07, 0xFF, 0x00, 0x0E, 0xFE, 0x00, 0x03, 0xDF, 0x80, 0x03, 0xEF, 0x80, 0x1B, 0xF1, 0xC2, 0x00, 0xE7, 0xE0, 0x18, 0xFC, 0xE0, 0x21, 0xFC, 0x80, 0x3C, 0xFC, 0x40, 0x0E, 0x7E,\r\n  //320\r\n  0x00, 0x3F, 0x3E, 0x00, 0x0F, 0xFE, 0x00, 0x1F, 0xFF, 0x00, 0x3E, 0xF0, 0x07, 0xFC, 0x00, 0x7E, 0x10, 0x3F, 0xFF, 0x00, 0x3F, 0x38, 0x0E, 0x7C, 0x01, 0x87, 0x0C, 0xFC, 0xC7, 0x00, 0x3E, 0x04,\r\n  //340\r\n  0x0F, 0x3E, 0x1F, 0x0F, 0x0F, 0x1F, 0x0F, 0x02, 0x83, 0x87, 0xCF, 0x03, 0x87, 0x0F, 0x3F, 0xC0, 0x07, 0x9E, 0x60, 0x3F, 0xC0, 0x03, 0xFE, 0x00, 0x3F, 0xE0, 0x77, 0xE1, 0xC0, 0xFE, 0xE0, 0xC3,\r\n  //360\r\n  0xE0, 0x01, 0xDF, 0xF8, 0x03, 0x07, 0x00, 0x7E, 0x70, 0x00, 0x7C, 0x38, 0x18, 0xFE, 0x0C, 0x1E, 0x78, 0x1C, 0x7C, 0x3E, 0x0E, 0x1F, 0x1E, 0x1E, 0x3E, 0x00, 0x7F, 0x83, 0x07, 0xDB, 0x87, 0x83,\r\n  //380\r\n  0x07, 0xC7, 0x07, 0x10, 0x71, 0xFF, 0x00, 0x3F, 0xE2, 0x01, 0xE0, 0xC1, 0xC3, 0xE1, 0x00, 0x7F, 0xC0, 0x05, 0xF0, 0x20, 0xF8, 0xF0, 0x70, 0xFE, 0x78, 0x79, 0xF8, 0x02, 0x3F, 0x0C, 0x8F, 0x03,\r\n  //3a0\r\n  0x0F, 0x9F, 0xE0, 0xC1, 0xC7, 0x87, 0x03, 0xC3, 0xC3, 0xB0, 0xE1, 0xE1, 0xC1, 0xE3, 0xE0, 0x71, 0xF0, 0x00, 0xFC, 0x70, 0x7C, 0x0C, 0x3E, 0x38, 0x0E, 0x1C, 0x70, 0xC3, 0xC7, 0x03, 0x81, 0xC1,\r\n  //3c0\r\n  0xC7, 0xE7, 0x00, 0x0F, 0xC7, 0x87, 0x19, 0x09, 0xEF, 0xC4, 0x33, 0xE0, 0xC1, 0xFC, 0xF8, 0x70, 0xF0, 0x78, 0xF8, 0xF0, 0x61, 0xC7, 0x00, 0x1F, 0xF8, 0x01, 0x7C, 0xF8, 0xF0, 0x78, 0x70, 0x3C,\r\n  //3e0\r\n  0x7C, 0xCE, 0x0E, 0x21, 0x83, 0xCF, 0x08, 0x07, 0x8F, 0x08, 0xC1, 0x87, 0x8F, 0x80, 0xC7, 0xE3, 0x00, 0x07, 0xF8, 0xE0, 0xEF, 0x00, 0x39, 0xF7, 0x80, 0x0E, 0xF8, 0xE1, 0xE3, 0xF8, 0x21, 0x9F,\r\n  //400 /X  (glottal)\r\n  0xC0, 0xFF, 0x03, 0xF8, 0x07, 0xC0, 0x1F, 0xF8, 0xC4, 0x04, 0xFC, 0xC4, 0xC1, 0xBC, 0x87, 0xF0, 0x0F, 0xC0, 0x7F, 0x05, 0xE0, 0x25, 0xEC, 0xC0, 0x3E, 0x84, 0x47, 0xF0, 0x8E, 0x03, 0xF8, 0x03,\r\n  //420\r\n  0xFB, 0xC0, 0x19, 0xF8, 0x07, 0x9C, 0x0C, 0x17, 0xF8, 0x07, 0xE0, 0x1F, 0xA1, 0xFC, 0x0F, 0xFC, 0x01, 0xF0, 0x3F, 0x00, 0xFE, 0x03, 0xF0, 0x1F, 0x00, 0xFD, 0x00, 0xFF, 0x88, 0x0D, 0xF9, 0x01,\r\n  //440\r\n  0xFF, 0x00, 0x70, 0x07, 0xC0, 0x3E, 0x42, 0xF3, 0x0D, 0xC4, 0x7F, 0x80, 0xFC, 0x07, 0xF0, 0x5E, 0xC0, 0x3F, 0x00, 0x78, 0x3F, 0x81, 0xFF, 0x01, 0xF8, 0x01, 0xC3, 0xE8, 0x0C, 0xE4, 0x64, 0x8F,\r\n  //460\r\n  0xE4, 0x0F, 0xF0, 0x07, 0xF0, 0xC2, 0x1F, 0x00, 0x7F, 0xC0, 0x6F, 0x80, 0x7E, 0x03, 0xF8, 0x07, 0xF0, 0x3F, 0xC0, 0x78, 0x0F, 0x82, 0x07, 0xFE, 0x22, 0x77, 0x70, 0x02, 0x76, 0x03, 0xFE, 0x00,\r\n  //480\r\n  0xFE, 0x67, 0x00, 0x7C, 0xC7, 0xF1, 0x8E, 0xC6, 0x3B, 0xE0, 0x3F, 0x84, 0xF3, 0x19, 0xD8, 0x03, 0x99, 0xFC, 0x09, 0xB8, 0x0F, 0xF8, 0x00, 0x9D, 0x24, 0x61, 0xF9, 0x0D, 0x00, 0xFD, 0x03, 0xF0,\r\n  //4a0\r\n  0x1F, 0x90, 0x3F, 0x01, 0xF8, 0x1F, 0xD0, 0x0F, 0xF8, 0x37, 0x01, 0xF8, 0x07, 0xF0, 0x0F, 0xC0, 0x3F, 0x00, 0xFE, 0x03, 0xF8, 0x0F, 0xC0, 0x3F, 0x00, 0xFA, 0x03, 0xF0, 0x0F, 0x80, 0xFF, 0x01,\r\n  //4c0\r\n  0xB8, 0x07, 0xF0, 0x01, 0xFC, 0x01, 0xBC, 0x80, 0x13, 0x1E, 0x00, 0x7F, 0xE1, 0x40, 0x7F, 0xA0, 0x7F, 0xB0, 0x00, 0x3F, 0xC0, 0x1F, 0xC0, 0x38, 0x0F, 0xF0, 0x1F, 0x80, 0xFF, 0x01, 0xFC, 0x03,\r\n  //4e0\r\n  0xF1, 0x7E, 0x01, 0xFE, 0x01, 0xF0, 0xFF, 0x00, 0x7F, 0xC0, 0x1D, 0x07, 0xF0, 0x0F, 0xC0, 0x7E, 0x06, 0xE0, 0x07, 0xE0, 0x0F, 0xF8, 0x06, 0xC1, 0xFE, 0x01, 0xFC, 0x03, 0xE0, 0x0F, 0x00, 0xFC];\r\n\r\n  /**\r\n   * SAM's voice can be altered by changing the frequencies of the\r\n   * mouth formant (F1) and the throat formant (F2). Only the\r\n   * vowel/diphthong and sonorant phonemes (5-29 and 48-53) are altered.\r\n   *\r\n   * This returns the three base frequency arrays.\r\n   *\r\n   * @param {Number} mouth  valid values: 0-255\r\n   * @param {Number} throat valid values: 0-255\r\n   *\r\n   * @return {Array}\r\n   */\r\n  let SetMouthThroat = (mouth, throat) => {\r\n    let trans = (factor, initialFrequency) => {\r\n      return (factor * initialFrequency >> 8 & 0xFF) << 1;\r\n    };\r\n    let freqdata = [[], [], []];\r\n    frequencyData.map((v, i) => {\r\n      freqdata[0][i] = v & 0xFF;\r\n      freqdata[1][i] = v >> 8 & 0xFF;\r\n      freqdata[2][i] = v >> 16 & 0xFF;\r\n    });\r\n\r\n    // recalculate formant frequencies 5..29 for the mouth (F1) and throat (F2)\r\n    for (let pos = 5; pos < 30; pos++) {\r\n      // recalculate mouth frequency\r\n      freqdata[0][pos] = trans(mouth, freqdata[0][pos]);\r\n\r\n      // recalculate throat frequency\r\n      freqdata[1][pos] = trans(throat, freqdata[1][pos]);\r\n    }\r\n\r\n    // recalculate formant frequencies 48..53\r\n    for (let pos = 48; pos < 54; pos++) {\r\n      // recalculate F1 (mouth formant)\r\n      freqdata[0][pos] = trans(mouth, freqdata[0][pos]);\r\n      // recalculate F2 (throat formant)\r\n      freqdata[1][pos] = trans(throat, freqdata[1][pos]);\r\n    }\r\n    return freqdata;\r\n  };\r\n\r\n  /**\r\n   * CREATE TRANSITIONS.\r\n   *\r\n   * Linear transitions are now created to smoothly connect each\r\n   * phoeneme. This transition is spread between the ending frames\r\n   * of the old phoneme (outBlendLength), and the beginning frames\r\n   * of the new phoneme (inBlendLength).\r\n   *\r\n   * To determine how many frames to use, the two phonemes are\r\n   * compared using the blendRank[] table. The phoneme with the\r\n   * smaller score is used. In case of a tie, a blend of each is used:\r\n   *\r\n   *      if blendRank[phoneme1] ==  blendRank[phomneme2]\r\n   *          // use lengths from each phoneme\r\n   *          outBlendFrames = outBlend[phoneme1]\r\n   *          inBlendFrames = outBlend[phoneme2]\r\n   *      else if blendRank[phoneme1] < blendRank[phoneme2]\r\n   *          // use lengths from first phoneme\r\n   *          outBlendFrames = outBlendLength[phoneme1]\r\n   *          inBlendFrames = inBlendLength[phoneme1]\r\n   *      else\r\n   *          // use lengths from the second phoneme\r\n   *          // note that in and out are swapped around!\r\n   *          outBlendFrames = inBlendLength[phoneme2]\r\n   *          inBlendFrames = outBlendLength[phoneme2]\r\n   *\r\n   *  Blend lengths can't be less than zero.\r\n   *\r\n   * For most of the parameters, SAM interpolates over the range of the last\r\n   * outBlendFrames-1 and the first inBlendFrames.\r\n   *\r\n   * The exception to this is the Pitch[] parameter, which is interpolates the\r\n   * pitch from the center of the current phoneme to the center of the next\r\n   * phoneme.\r\n   *\r\n   * @param {Uint8Array} pitches\r\n   * @param {Uint8Array} frequency\r\n   * @param {Uint8Array} amplitude\r\n   * @param {Array} tuples\r\n   *\r\n   * @return {Number}\r\n   */\r\n  let CreateTransitions = (pitches, frequency, amplitude, tuples) => {\r\n    // 0=pitches\r\n    // 1=frequency1\r\n    // 2=frequency2\r\n    // 3=frequency3\r\n    // 4=amplitude1\r\n    // 5=amplitude2\r\n    // 6=amplitude3\r\n    let tables = [pitches, frequency[0], frequency[1], frequency[2], amplitude[0], amplitude[1], amplitude[2]];\r\n    let Read = (table, pos) => {\r\n      {\r\n        if (table < 0 || table > tables.length - 1) {\r\n          throw new Error(`Error invalid table in Read: ${table}`);\r\n        }\r\n      }\r\n      return tables[table][pos];\r\n    };\r\n\r\n    // linearly interpolate values\r\n    let interpolate = (width, table, frame, change) => {\r\n      let sign = change < 0;\r\n      let remainder = Math.abs(change) % width;\r\n      let div = change / width | 0;\r\n      let error = 0;\r\n      let pos = width;\r\n      while (--pos > 0) {\r\n        let val = Read(table, frame) + div;\r\n        error += remainder;\r\n        if (error >= width) {\r\n          // accumulated a whole integer error, so adjust output\r\n          error -= width;\r\n          if (sign) {\r\n            val--;\r\n          } else if (val) {\r\n            // if input is 0, we always leave it alone\r\n            val++;\r\n          }\r\n        }\r\n\r\n        // Write updated value back to next frame.\r\n        {\r\n          if (table < 0 || table > tables.length - 1) {\r\n            throw new Error(`Error invalid table in Read: ${table}`);\r\n          }\r\n        }\r\n        tables[table][++frame] = val;\r\n        val += div;\r\n      }\r\n    };\r\n    let outBlendFrames;\r\n    let inBlendFrames;\r\n    let boundary = 0;\r\n    for (let pos = 0; pos < tuples.length - 1; pos++) {\r\n      let phoneme = tuples[pos][0];\r\n      let next_phoneme = tuples[pos + 1][0];\r\n\r\n      // get the ranking of each phoneme\r\n      let next_rank = blendRank[next_phoneme];\r\n      let rank = blendRank[phoneme];\r\n\r\n      // compare the rank - lower rank value is stronger\r\n      if (rank === next_rank) {\r\n        // same rank, so use out blend lengths from each phoneme\r\n        outBlendFrames = outBlendLength[phoneme];\r\n        inBlendFrames = outBlendLength[next_phoneme];\r\n      } else if (rank < next_rank) {\r\n        // next phoneme is stronger, so use its blend lengths\r\n        outBlendFrames = inBlendLength[next_phoneme];\r\n        inBlendFrames = outBlendLength[next_phoneme];\r\n      } else {\r\n        // current phoneme is stronger, so use its blend lengths\r\n        // note the out/in are swapped\r\n        outBlendFrames = outBlendLength[phoneme];\r\n        inBlendFrames = inBlendLength[phoneme];\r\n      }\r\n      boundary += tuples[pos][1];\r\n      let trans_end = boundary + inBlendFrames;\r\n      let trans_start = boundary - outBlendFrames;\r\n      let trans_length = outBlendFrames + inBlendFrames; // total transition\r\n\r\n      if ((trans_length - 2 & 128) === 0) {\r\n        // unlike the other values, the pitches[] interpolates from\r\n        // the middle of the current phoneme to the middle of the\r\n        // next phoneme\r\n\r\n        // half the width of the current and next phoneme\r\n        let cur_width = tuples[pos][1] >> 1;\r\n        let next_width = tuples[pos + 1][1] >> 1;\r\n        let pitch = pitches[boundary + next_width] - pitches[boundary - cur_width];\r\n        // interpolate the values\r\n        interpolate(cur_width + next_width, 0, trans_start, pitch);\r\n        for (let table = 1; table < 7; table++) {\r\n          // tables:\r\n          // 0  pitches\r\n          // 1  frequency1\r\n          // 2  frequency2\r\n          // 3  frequency3\r\n          // 4  amplitude1\r\n          // 5  amplitude2\r\n          // 6  amplitude3\r\n          let value = Read(table, trans_end) - Read(table, trans_start);\r\n          interpolate(trans_length, table, trans_start, value);\r\n        }\r\n      }\r\n    }\r\n\r\n    // add the length of last phoneme\r\n    return boundary + tuples[tuples.length - 1][1];\r\n  };\r\n\r\n  let RISING_INFLECTION = 255;\r\n  let FALLING_INFLECTION = 1;\r\n\r\n  /** CREATE FRAMES\r\n   *\r\n   * The length parameter in the list corresponds to the number of frames\r\n   * to expand the phoneme to. At the default speed, each frame represents\r\n   * about 10 milliseconds of time.\r\n   * So a phoneme with a length of 7 = 7 frames = 70 milliseconds duration.\r\n   *\r\n   * The parameters are copied from the phoneme to the frame verbatim.\r\n   *\r\n   * Returns:\r\n   *   [\r\n   *      pitches,\r\n   *      frequency,\r\n   *      amplitude,\r\n   *      sampledConsonantFlag\r\n   *   ]\r\n   *\r\n   * @param {Number}       pitch          Input\r\n   * @param {Array}        tuples         Input\r\n   * @param {Uint8Array[]} frequencyData  Input\r\n   *\r\n   * @return Array\r\n   */\r\n  let CreateFrames = (pitch, tuples, frequencyData) => {\r\n    /**\r\n     * Create a rising or falling inflection 30 frames prior to index X.\r\n     * A rising inflection is used for questions, and a falling inflection is used for statements.\r\n     */\r\n    let AddInflection = (inflection, pos, pitches) => {\r\n      // store the location of the punctuation\r\n      let end = pos;\r\n      if (pos < 30) {\r\n        pos = 0;\r\n      } else {\r\n        pos -= 30;\r\n      }\r\n      let A;\r\n      // FIXME: Explain this fix better, it's not obvious\r\n      // ML : A =, fixes a problem with invalid pitch with '.'\r\n      while ((A = pitches[pos]) === 127) {\r\n        ++pos;\r\n      }\r\n      while (pos !== end) {\r\n        // add the inflection direction\r\n        A += inflection;\r\n\r\n        // set the inflection\r\n        pitches[pos] = A & 0xFF;\r\n        while (++pos !== end && pitches[pos] === 255) {/* keep looping */}\r\n      }\r\n    };\r\n    let pitches = [];\r\n    let frequency = [[], [], []];\r\n    let amplitude = [[], [], []];\r\n    let sampledConsonantFlag = [];\r\n    let X = 0;\r\n    for (let i = 0; i < tuples.length; i++) {\r\n      // get the phoneme at the index\r\n      let phoneme = tuples[i][0];\r\n      if (phoneme === PHONEME_PERIOD) {\r\n        AddInflection(FALLING_INFLECTION, X, pitches);\r\n      } else if (phoneme === PHONEME_QUESTION) {\r\n        AddInflection(RISING_INFLECTION, X, pitches);\r\n      }\r\n\r\n      // get the stress amount (more stress = higher pitch)\r\n      let phase1 = stressPitch_tab47492[tuples[i][2]];\r\n      // get number of frames to write\r\n      // copy from the source to the frames list\r\n      for (let frames = tuples[i][1]; frames > 0; frames--) {\r\n        frequency[0][X] = frequencyData[0][phoneme]; // F1 frequency\r\n        frequency[1][X] = frequencyData[1][phoneme]; // F2 frequency\r\n        frequency[2][X] = frequencyData[2][phoneme]; // F3 frequency\r\n        amplitude[0][X] = ampldata[phoneme] & 0xFF; // F1 amplitude\r\n        amplitude[1][X] = ampldata[phoneme] >> 8 & 0xFF; // F2 amplitude\r\n        amplitude[2][X] = ampldata[phoneme] >> 16 & 0xFF; // F3 amplitude\r\n        sampledConsonantFlag[X] = sampledConsonantFlags[phoneme]; // phoneme data for sampled consonants\r\n        pitches[X] = pitch + phase1 & 0xFF; // pitch\r\n        X++;\r\n      }\r\n    }\r\n    return [pitches, frequency, amplitude, sampledConsonantFlag];\r\n  };\r\n\r\n  let PrepareFrames = (phonemes, pitch, mouth, throat, singmode) => {\r\n    let freqdata = SetMouthThroat(mouth, throat);\r\n\r\n    /**\r\n     * RENDER THE PHONEMES IN THE LIST\r\n     *\r\n     * The phoneme list is converted into sound through the steps:\r\n     *\r\n     * 1. Copy each phoneme <length> number of times into the frames list.\r\n     *\r\n     * 2. Determine the transitions lengths between phonemes, and linearly\r\n     *    interpolate the values across the frames.\r\n     *\r\n     * 3. Offset the pitches by the fundamental frequency.\r\n     *\r\n     * 4. Render the each frame.\r\n     */\r\n\r\n    const [pitches, frequency, amplitude, sampledConsonantFlag] = CreateFrames(pitch, phonemes, freqdata);\r\n    let t = CreateTransitions(pitches, frequency, amplitude, phonemes);\r\n    if (!singmode) {\r\n      /* ASSIGN PITCH CONTOUR\r\n       *\r\n       * This subtracts the F1 frequency from the pitch to create a\r\n       * pitch contour. Without this, the output would be at a single\r\n       * pitch level (monotone).\r\n       */\r\n      for (let i = 0; i < pitches.length; i++) {\r\n        // subtract half the frequency of the formant 1.\r\n        // this adds variety to the voice\r\n        pitches[i] -= frequency[0][i] >> 1;\r\n      }\r\n    }\r\n\r\n    /*\r\n     * RESCALE AMPLITUDE\r\n     *\r\n     * Rescale volume from decibels to the linear scale.\r\n     */\r\n    let amplitudeRescale = [0x00, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x08, 0x09, 0x0B, 0x0D, 0x0F];\r\n    for (let i = amplitude[0].length - 1; i >= 0; i--) {\r\n      amplitude[0][i] = amplitudeRescale[amplitude[0][i]];\r\n      amplitude[1][i] = amplitudeRescale[amplitude[1][i]];\r\n      amplitude[2][i] = amplitudeRescale[amplitude[2][i]];\r\n    }\r\n    let result = [t, frequency, pitches, amplitude, sampledConsonantFlag];\r\n    return result;\r\n  };\r\n\r\n  let CreateOutputBuffer = buffersize => {\r\n    let buffer = new Uint8Array(buffersize);\r\n    let bufferpos = 0;\r\n    let oldTimeTableIndex = 0;\r\n    // Scale by 16 and write five times.\r\n    let writer = (index, A) => {\r\n      let scaled = (A & 15) * 16;\r\n      writer.ary(index, [scaled, scaled, scaled, scaled, scaled]);\r\n    };\r\n    // Write the five given values.\r\n    writer.ary = (index, array) => {\r\n      // timetable for more accurate c64 simulation\r\n      let timetable = [[162, 167, 167, 127, 128],\r\n      // formants synth\r\n      [226, 60, 60, 0, 0],\r\n      // unvoiced sample 0\r\n      [225, 60, 59, 0, 0],\r\n      // unvoiced sample 1\r\n      [200, 0, 0, 54, 55],\r\n      // voiced sample 0\r\n      [199, 0, 0, 54, 54] // voiced sample 1\r\n      ];\r\n      bufferpos += timetable[oldTimeTableIndex][index];\r\n      if ((bufferpos / 50 | 0) > buffer.length) {\r\n        {\r\n          throw new Error(`Buffer overflow, want ${bufferpos / 50 | 0} but buffersize is only ${buffer.length}!`);\r\n        }\r\n      }\r\n      oldTimeTableIndex = index;\r\n      // write a little bit in advance\r\n      for (let k = 0; k < 5; k++) {\r\n        buffer[(bufferpos / 50 | 0) + k] = array[k];\r\n      }\r\n    };\r\n    writer.get = () => {\r\n      return buffer.slice(0, bufferpos / 50 | 0);\r\n    };\r\n    return writer;\r\n  };\r\n\r\n  let RenderSample = (Output, lastSampleOffset, consonantFlag, pitch) => {\r\n    // mask low three bits and subtract 1 get value to\r\n    // convert 0 bits on unvoiced samples.\r\n    let kind = (consonantFlag & 7) - 1;\r\n\r\n    // determine which value to use from table { 0x18, 0x1A, 0x17, 0x17, 0x17 }\r\n    // T', S, Z               0          0x18   coronal\r\n    // CH', J', SH, ZH        1          0x1A   palato-alveolar\r\n    // P', F, V, TH, DH       2          0x17   [labio]dental\r\n    // /H                     3          0x17   palatal\r\n    // /X                     4          0x17   glottal\r\n\r\n    let samplePage = kind * 256 & 0xFFFF; // unsigned short\r\n    let off = consonantFlag & 248; // unsigned char\r\n\r\n    let renderSample = (index1, value1, index0, value0) => {\r\n      let bit = 8;\r\n      let sample = sampleTable[samplePage + off];\r\n      do {\r\n        if ((sample & 128) !== 0) {\r\n          Output(index1, value1);\r\n        } else {\r\n          Output(index0, value0);\r\n        }\r\n        sample <<= 1;\r\n      } while (--bit);\r\n    };\r\n    if (off === 0) {\r\n      // voiced phoneme: Z*, ZH, V*, DH\r\n      let phase1 = pitch >> 4 ^ 255 & 0xFF; // unsigned char\r\n      off = lastSampleOffset & 0xFF; // unsigned char\r\n      do {\r\n        renderSample(3, 26, 4, 6);\r\n        off++;\r\n        off &= 0xFF;\r\n      } while (++phase1 & 0xFF);\r\n      return off;\r\n    }\r\n    // unvoiced\r\n    off = off ^ 255 & 0xFF; // unsigned char\r\n    let value0 = sampledConsonantValues0[kind] & 0xFF; // unsigned char\r\n    do {\r\n      renderSample(2, 5, 1, value0);\r\n    } while (++off & 0xFF);\r\n    return lastSampleOffset;\r\n  };\r\n\r\n  // Removed sine table stored a pre calculated sine wave but in modern CPU, we can calculate inline.\r\n  let sinus = x => Math.sin(2 * Math.PI * (x / 256)) * 127 | 0;\r\n\r\n  /**\r\n   * PROCESS THE FRAMES\r\n   *\r\n   * In traditional vocal synthesis, the glottal pulse drives filters, which\r\n   * are attenuated to the frequencies of the formants.\r\n   *\r\n   * SAM generates these formants directly with sine and rectangular waves.\r\n   * To simulate them being driven by the glottal pulse, the waveforms are\r\n   * reset at the beginning of each glottal pulse.\r\n   */\r\n  let ProcessFrames = (Output, frameCount, speed, frequency, pitches, amplitude, sampledConsonantFlag) => {\r\n    let speedcounter = speed;\r\n    let phase1 = 0;\r\n    let phase2 = 0;\r\n    let phase3 = 0;\r\n    let lastSampleOffset = 0;\r\n    let pos = 0;\r\n    let glottal_pulse = pitches[0];\r\n    let mem38 = glottal_pulse * .75 | 0;\r\n    while (frameCount) {\r\n      let flags = sampledConsonantFlag[pos];\r\n\r\n      // unvoiced sampled phoneme?\r\n      if ((flags & 248) !== 0) {\r\n        lastSampleOffset = RenderSample(Output, lastSampleOffset, flags, pitches[pos & 0xFF]);\r\n        // skip ahead two in the phoneme buffer\r\n        pos += 2;\r\n        frameCount -= 2;\r\n        speedcounter = speed;\r\n      } else {\r\n        {\r\n          // Rectangle wave consisting of:\r\n          //   0-128 = 0x90\r\n          // 128-255 = 0x70\r\n\r\n          // simulate the glottal pulse and formants\r\n          let ary = [];\r\n          let /* unsigned int */p1 = phase1 * 256; // Fixed point integers because we need to divide later on\r\n          let /* unsigned int */p2 = phase2 * 256;\r\n          let /* unsigned int */p3 = phase3 * 256;\r\n          for (let k = 0; k < 5; k++) {\r\n            const /* signed char */sp1 = sinus(0xff & p1 >> 8);\r\n            const /* signed char */sp2 = sinus(0xff & p2 >> 8);\r\n            const /* signed char */rp3 = (0xff & p3 >> 8) < 129 ? -0x70 : 0x70;\r\n            const /* signed int */sin1 = sp1 * ( /* (unsigned char) */amplitude[0][pos] & 0x0F);\r\n            const /* signed int */sin2 = sp2 * ( /* (unsigned char) */amplitude[1][pos] & 0x0F);\r\n            const /* signed int */rect = rp3 * ( /* (unsigned char) */amplitude[2][pos] & 0x0F);\r\n            let /* signed int */mux = sin1 + sin2 + rect;\r\n            mux /= 32;\r\n            mux += 128; // Go from signed to unsigned amplitude\r\n            ary[k] = mux | 0;\r\n            p1 += frequency[0][pos] * 256 / 4; // Compromise, this becomes a shift and works well\r\n            p2 += frequency[1][pos] * 256 / 4;\r\n            p3 += frequency[2][pos] * 256 / 4;\r\n          }\r\n          Output.ary(0, ary);\r\n        }\r\n        speedcounter--;\r\n        if (speedcounter === 0) {\r\n          pos++; //go to next amplitude\r\n          // decrement the frame count\r\n          frameCount--;\r\n          if (frameCount === 0) {\r\n            return;\r\n          }\r\n          speedcounter = speed;\r\n        }\r\n        glottal_pulse--;\r\n        if (glottal_pulse !== 0) {\r\n          // not finished with a glottal pulse\r\n\r\n          mem38--;\r\n          // within the first 75% of the glottal pulse?\r\n          // is the count non-zero and the sampled flag is zero?\r\n          if (mem38 !== 0 || flags === 0) {\r\n            // update the phase of the formants\r\n            // TODO: we should have a switch to disable this, it causes a pretty nice voice without the masking!\r\n            phase1 = phase1 + frequency[0][pos]; // & 0xFF;\r\n            phase2 = phase2 + frequency[1][pos]; // & 0xFF;\r\n            phase3 = phase3 + frequency[2][pos]; // & 0xFF;\r\n            continue;\r\n          }\r\n\r\n          // voiced sampled phonemes interleave the sample with the\r\n          // glottal pulse. The sample flag is non-zero, so render\r\n          // the sample for the phoneme.\r\n          lastSampleOffset = RenderSample(Output, lastSampleOffset, flags, pitches[pos & 0xFF]);\r\n        }\r\n      }\r\n      glottal_pulse = pitches[pos];\r\n      mem38 = glottal_pulse * .75 | 0;\r\n\r\n      // reset the formant wave generators to keep them in\r\n      // sync with the glottal pulse\r\n      phase1 = 0;\r\n      phase2 = 0;\r\n      phase3 = 0;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @param {Array} phonemes\r\n   * @param {Number} [pitch]\r\n   * @param {Number} [mouth]\r\n   * @param {Number} [throat]\r\n   * @param {Number} [speed]\r\n   * @param {Boolean} [singmode]\r\n   *\r\n   * @return Uint8Array\r\n   */\r\n  let Renderer = (phonemes, pitch, mouth, throat, speed, singmode) => {\r\n    pitch = pitch === undefined ? 64 : pitch & 0xFF;\r\n    mouth = mouth === undefined ? 128 : mouth & 0xFF;\r\n    throat = throat === undefined ? 128 : throat & 0xFF;\r\n    speed = (speed || 72) & 0xFF;\r\n    singmode = singmode || false;\r\n    let sentences = PrepareFrames(phonemes, pitch, mouth, throat, singmode);\r\n\r\n    // Reserve 176.4*speed samples (=8*speed ms) for each frame.\r\n    let Output = CreateOutputBuffer(176.4 // = (22050/125)\r\n    * phonemes.reduce((pre, v) => pre + v[1], 0) // Combined phoneme length in frames.\r\n    * speed | 0);\r\n    const [t, frequency, pitches, amplitude, sampledConsonantFlag] = sentences;\r\n    {\r\n      PrintOutput(pitches, frequency, amplitude, sampledConsonantFlag);\r\n    }\r\n    ProcessFrames(Output, t, speed, frequency, pitches, amplitude, sampledConsonantFlag);\r\n    return Output.get();\r\n  };\r\n  let PrintOutput = (pitches, frequency, amplitude, sampledConsonantFlag) => {\r\n    let pad = num => {\r\n      let s = '00000' + num;\r\n      return s.substr(s.length - 5);\r\n    };\r\n    console.log('===========================================');\r\n    console.log('Final data for speech output:');\r\n    console.log(' flags ampl1 freq1 ampl2 freq2 ampl3 freq3 pitch');\r\n    console.log('------------------------------------------------');\r\n    for (let i = 0; i < sampledConsonantFlag.length; i++) {\r\n      console.log(' %s %s %s %s %s %s %s %s', pad(sampledConsonantFlag[i]), pad(amplitude[0][i]), pad(frequency[0][i]), pad(amplitude[1][i]), pad(frequency[1][i]), pad(amplitude[2][i]), pad(frequency[2][i]), pad(pitches[i]));\r\n      i++;\r\n    }\r\n    console.log('===========================================');\r\n  };\r\n\r\n  /**\r\n   * Process the input and return the audio buffer.\r\n   *\r\n   * @param {String} input\r\n   *\r\n   * @param {object}  [options]\r\n   * @param {Boolean} [options.singmode] Default false.\r\n   * @param {Number}  [options.pitch]    Default 64.\r\n   * @param {Number}  [options.speed]    Default 72.\r\n   * @param {Number}  [options.mouth]    Default 128.\r\n   * @param {Number}  [options.throat]   Default 128.\r\n   *\r\n   * @return {Float32Array|Boolean}\r\n   */\r\n  let SamBuffer = (input, options) => {\r\n    let buffer = SamProcess(input, options);\r\n    if (false === buffer) {\r\n      return false;\r\n    }\r\n    return Uint8ArrayToFloat32Array(buffer);\r\n  };\r\n\r\n  /**\r\n   * Process the input and return the audiobuffer.\r\n   *\r\n   * @param {String} input\r\n   *\r\n   * @param {object}  [options]\r\n   * @param {Boolean} [options.singmode] Default false.\r\n   * @param {Number}  [options.pitch]    Default 64.\r\n   * @param {Number}  [options.speed]    Default 72.\r\n   * @param {Number}  [options.mouth]    Default 128.\r\n   * @param {Number}  [options.throat]   Default 128.\r\n   *\r\n   * @return {Uint8Array|Boolean}\r\n   */\r\n  let SamProcess = function (input) {\r\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    let parsed = Parser(input);\r\n    if (false === parsed) {\r\n      return false;\r\n    }\r\n    return Renderer(parsed, options.pitch, options.mouth, options.throat, options.speed, options.singmode);\r\n  };\r\n\r\n  let convert = TextToPhonemes;\r\n  let buf8 = SamProcess;\r\n  let buf32 = SamBuffer;\r\n\r\n  /**\r\n   * @param {object}  [options]\r\n   * @param {Boolean} [options.phonetic] Default false.\r\n   * @param {Boolean} [options.singmode] Default false.\r\n   * @param {Boolean} [options.debug]    Default false.\r\n   * @param {Number}  [options.pitch]    Default 64.\r\n   * @param {Number}  [options.speed]    Default 72.\r\n   * @param {Number}  [options.mouth]    Default 128.\r\n   * @param {Number}  [options.throat]   Default 128.\r\n   *\r\n   * @constructor\r\n   */\r\n  function SamJs(options) {\r\n    let opts = options || {};\r\n    let ensurePhonetic = (text, phonetic) => {\r\n      if (!(phonetic || opts.phonetic)) {\r\n        return convert(text);\r\n      }\r\n      return text.toUpperCase();\r\n    };\r\n\r\n    /**\r\n     * Render the passed text as 8bit wave buffer array.\r\n     *\r\n     * @param {string}  text       The text to render or phoneme string.\r\n     * @param {boolean} [phonetic] Flag if the input text is already phonetic data.\r\n     *\r\n     * @return {Uint8Array|Boolean}\r\n     */\r\n    this.buf8 = (text, phonetic) => buf8(ensurePhonetic(text, phonetic), opts);\r\n\r\n    /**\r\n     * Render the passed text as 32bit wave buffer array.\r\n     *\r\n     * @param {string}  text       The text to render or phoneme string.\r\n     * @param {boolean} [phonetic] Flag if the input text is already phonetic data.\r\n     *\r\n     * @return {Float32Array|Boolean}\r\n     */\r\n    this.buf32 = (text, phonetic) => buf32(ensurePhonetic(text, phonetic), opts);\r\n\r\n    /**\r\n     * Render the passed text as wave buffer and play it over the speakers.\r\n     *\r\n     * @param {string}  text       The text to render or phoneme string.\r\n     * @param {boolean} [phonetic] Flag if the input text is already phonetic data.\r\n     *\r\n     * @return {Promise}\r\n     */\r\n    this.speak = (text, phonetic) => PlayBuffer(this.buf32(text, phonetic));\r\n\r\n    /**\r\n     * Render the passed text as wave buffer and download it via URL API.\r\n     *\r\n     * @param {string}  text       The text to render or phoneme string.\r\n     * @param {boolean} [phonetic] Flag if the input text is already phonetic data.\r\n     *\r\n     * @return void\r\n     */\r\n    this.download = (text, phonetic) => {\r\n      RenderBuffer(this.buf8(text, phonetic));\r\n    };\r\n\r\n    /**\r\n     * Render the passed text as wave buffer array.\r\n     * \r\n     * @param {string}  text       The text to render or phoneme string.\r\n     * @param {boolean} [phonetic] Flag if the input text is already phonetic data.\r\n     * \r\n     * @return {Uint8Array|false}\r\n     */\r\n    this.wav = (text, phonetic) => ToWavBuffer(this.buf8(text, phonetic));\r\n  }\r\n  SamJs.buf8 = buf8;\r\n  SamJs.buf32 = buf32;\r\n  SamJs.convert = convert;\r\n\r\n  return SamJs;\r\n\r\n}));\r\n\r\n\r\n const opts = {debug: 1, pitch: $pitch, speed: $speed, mouth: $mouth, throat: $throat};\r\n\r\n  \r\n    document.addEventListener('DOMContentLoaded', function() {\r\n      const input = document.getElementById('speechinput');\r\n      const controls = {};\r\n  \r\n      let speech;\r\n        speech = (new SamJs(opts)).speak('$samargs');\r\n        speech.catch(() => {});\r\n    });"},"Duration":"6000","EntranceAnimation":{"$type":"MixItUp.Base.Model.Overlay.OverlayAnimationV3Model, MixItUp.Base","StartTime":0.0,"AnimateCSSAnimation":0,"WoahCSSAnimation":0},"ExitAnimation":{"$type":"MixItUp.Base.Model.Overlay.OverlayAnimationV3Model, MixItUp.Base","StartTime":0.0,"AnimateCSSAnimation":0,"WoahCSSAnimation":0},"CustomAnimations":[],"WidgetID":"00000000-0000-0000-0000-000000000000","ShowWidget":false,"StreamBossID":"00000000-0000-0000-0000-000000000000","StreamBossDamageAmount":null,"StreamBossForceDamage":false,"GoalID":"00000000-0000-0000-0000-000000000000","GoalAmount":null,"PersistentTimerID":"00000000-0000-0000-0000-000000000000","TimeAmount":null,"PauseUnpausePersistentTimer":null,"EndCreditsID":"00000000-0000-0000-0000-000000000000","EndCreditsSectionID":"00000000-0000-0000-0000-000000000000","EndCreditsItemText":null,"EventListID":"00000000-0000-0000-0000-000000000000","EventListDetails":null,"WheelID":"00000000-0000-0000-0000-000000000000","RunWidgetFunctionID":"00000000-0000-0000-0000-000000000000","RunWidgetFunctionName":null,"RunWidgetFunctionParameters":{"$type":"System.Collections.Generic.Dictionary`2[[System.String, mscorlib],[System.Object, mscorlib]], mscorlib"},"ID":"70306cce-054a-4688-bf60-3feca11edcfe","Name":"SAM","Type":5,"Enabled":true}]}